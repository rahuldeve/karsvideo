# dfs-0
 Lecture # 30                   Applications of DFS in Directed Graphsso today we are going to look at more applications of depth first search indirected graphs um recall that in the last class i had mentioned that wewil talk about strong connectivity right we will check we will see out tofigure outif a given directed graph is strongly connected or not and i have definewhat is strong connectivity meansessentially means that between every pair of vertices ordered pair ofvertices there is a path in the graphso which means i take two vertices lets say u and v there should be pathfrom u to v and also a path from v to uthen we would call the graph strongly connected right so in the last classthere was a very simple algorithm that was suggested which was thattake a vertex do a dfs from there take another vertex do a dfs from thereand so and on which means do a dfs from every vertex  in the graphif in each one this DFS's we include all the vertices of the graph onlythen is the graph strongly connected rightthat should be easy to see lets see if we can reduce the number of DFScalls that we make instead of making n DFS's can we reduce the number ofDFS from n to lets say some small number so[noise] lets say i take onevertex v and i do a DFS from here and when i do a DFS from here i visit allthe vertices in the graphthis is the lets say the DFS tree i obtain and as you and these if therewere the only vertices in the graph then i have visited all the vertices inthe graph yeahso what do i know i know that there is a path from v to every vertex in thegraph so if in my DFS from v so if DFS v visits all vertices then allvertices in graph G then there exists a path from v to every vertex in Grightsuppose we could some how figure out so suppose we could all do thefollowing we could some how figure out that there exists or i could or iclaim there exits a path from every vertex in G to v rightlets assume this is the case suppose this is true suppose this is true thatis [hindi] then does that imply that the graph is strongly connected[student: yes um ]so basically we are saying one plus two implies G is strongly connected(4.33) why [student: because um to find path ] right so if we have to finda path between some two vertices like say x and yso what will i do [student: um x to v then v to y] go from x to v [student:then v to y ]so go from 
# dfs-1
 to v yeah by by the statement two there is such apath from every vertex to v there is a path and then i go from v to y bystatement onethere is a path from v to y so all i need to somehow ensure is that thereexist a path from every vertex in the graph to v[Refer Slide: 05.25]                                    [pic]how will i ensure this this says that there is a path from v to everyvertex in the graph if i can ensure that there is a path from every vertexin the graph to v (5.25)how will i ensure that from every vertex in the graph there is a path to v[student: um from the lower most vertex um we are ending first startingfrom the path deepest back edge have as a back edge okay ]so this is the question how do i how do i ensure that there is a path fromevery vertex to v so how do i check how do i check if there is a path fromevery vertex to v how do i do this[student: sir we can um back edges and so also] thing fresh think ofsomething new [student: also we need the cross edges to if there are somecross edges so we can go along from them to ]suppose i were to do the following i took my graph G and i reversed [hindi]reverse edges to get a graph G sup R [hindi][student: do DFS from that vertex again now it look at a path ] now DFSokay so do DFS [student: that gives now] do DFS v on this graph G of sup R[hindi][student: if you get all the vertices um ] if all vertices are visited[hindi] if all vertices are visited [hindi]if all vertices are visited then this implies in G there is a path fromevery vertex to v yes or no[Refer Slide: 08.14]                                    [pic][hindi] [student: yes sir] if every vertex gets visited in this in this DFSthen i can say that the graph is strongly connected [hindi]in this graph there is no path from this from v to this vertex which meanthat in the original graph  there is no path from this vertex to thisvertex which means that the original graph is not strongly connected[hindi][student: in adjacency list we can fetch change the function go along ] wecan also the function DFS instead of looking at out adjacency edges we canlook at inadjcenecy edgeswe don't even have to 
# dfs-2
 the graph then right [hindi]so essentially by using two DFS's you can figure out if the graph isstrongly connected or not yesso everyone understands the procedure let me write down what the procedureis pick an arbitrary vertex vdo DFS v reverse G do DFS v on G reverse if all vertices are visited inboth DFS's then G is strongly connected else G is not strongly connectedis this clear to all [hindi][Refer Slide: 11.19]                                    [pic]we will now try to do with one DFS right its its an academic exercise forthis problem but at least you will learn you know the properties of DFS andbecause this is  perfectly fine algorithm and it just requires two DFS's toit okayso lets look at another way of checking if a graph is strongly connected ornot now we will use our whole gammon of definitions and terminologies rightokayso what are we going to do now we are going to do a DFS right we start froma vertex and we do a DFS so lets say these are my these are the red edgeswhich form the DFS tree[student: um] [hindi] okay suppose this is what i get my DFS tree as now iremarked in the last class that we are going to use ideas similar to wewhat we developed for two edge connectivityso two edge connectivity [hindi] we were saying that when we are backtracking lets say backtracking from this vertex i am going back to theparent because i have finished everythingi ensure that there is some edge which goes from this sub tree to wherewill it go it can only go an ancestor or above right because we said thereare only back edges in the case of undirected DFS so if an edge goes out ofhereit cannot go to one of these nodes it can go only to an ancestor right sowe said we would like to have one such edgenow we need similar such thing in the case of strong connectivity from herewe would like that there is some edge going out out [hindi]what are we what kind of edges will be going out of this sub tree only backedges right but if this were the sub tree i was considering right thenthere could be also be you know either there is back edge out of this subtree or there is a cross edge out of this sub treeso i could also have an edge going like this can happen rightso this edge is also an edge going out of this sub tree if there is an edgegoing out of the sub tree i am happy right okaythis is the only thing we will require clearly this 
# dfs-3
 required this isnecessary if from this sub tree there is no edge going out then this graphis not strongly connected why[student: because we can only ] because then you can only enter the subtree we can only come to these set of vertices we can go out of this set ofvertices what i mean by that is that if there were no edge going out ofthis sub treethen i can go from this vertex to the root for instance to vertex v becausethere is no edge going out of this four edgesthis is like an island in itself you can only come into here but you cannotgo out of here[student: but if a edge is going out what do you um ] yeah so all i amsaying is that we require it is necessary that an edge go out whether thatis sufficient we have to figure out it is clearly necessary that an edgegoes out of every sub treeyou understand the difference between necessary and sufficiency right so itis necessary that an edge go out of every sub treeyou understand what i mean by out of every sub tree so you are looking atthe sub tree what is a sub tree hereit is the descendance of any one vertex take any one vertex look at all itsdescendant that's a sub tree we are interested in yeahand there has to be one at least one edge going out of that yes this isclearly necessary [hindi] no edges is going out of that sub tree then wecan stop the process at that point stop our DFS and say that this graph isnot strongly connected yes agree with menow we will see how we can check this thing we will look at the procedurewe will look at what modification to make to the DFSso that we can check that there is an edge going out of every subtree thecheck would be very similar what we did for the case of two edgeconnectivity rightbut now lets see that this condition is also sufficient if from every subtree there is an edge going out then the graph is two edge connectedthe graph is strongly connected [hindi] yes why[student: um ] why [student: arrival time is the difficulty ] of what[student: all the sub trees if there is an edge from here to some other subtree] yeah[student: the vertex that is feature will have a lower arrival time ] willhave a lower arrival time then whom[student: then the vertex um in all the vertices of the sub tree ] okaygood close al most thereso what am i going to do [hindi] from the root i can reach every vertex nowall i have to show you is that from every vertex i can the rootif i can reach the root from every vertex i am done yes because then how doi find a path between 
# dfs-4
 and yi go from x to the root and from the root i go to y so all i have to showyou is a path from every vertex to the rootso we want to find a path from every vertex to the root [hindi]we take some vertex right lets say this is the vertex x i want to go from xto the root v how will i go well i am going to look at the subtree rootedat x [hindi] x is some vertex somewhere in my DFS [hindi]will it be smaller than x or larger than x [student: smaller] smaller thanx and [hindi] smaller because this is a cross edgeyou would have first come here in fact [hindi] right yeah so lets give thisname suppose this node is w rightso i can reach a node w so what have we said we have said that from x can igo from x to w [student: yes yes ] yes [student: yes we can go ] yes yeahwhy because this is a sub tree these are all descendant this node is also adecendant of xwhich means that i can come to this node and then i can take this edge andget to w so what's the big deal about to getting to wfrom x i can get to a node which has a strictly smaller arrival time then xyeah now from w i can repeat the same process from w i can get to a nodewhich has a strictly smaller arrival time than wwhich means that may be [hindi] now what do you know you know that thearrival time of x is strictly larger than the arrival time of w which isstrictly larger than the arrival time of a which is strictly arrival timeof  c [hindi]we can i can get to a node with the smaller arrival time [hindi] [student:when you reach um]  when i reach the root rightso that will give me a path from this node to the root [hindi] just thisrequirement that an edge go out of every subtree is both necessary andsufficient just this requirement and this is an easy requirement to checkyeah and we are going to do that next everyone with me[Refer Slide: 21.44]                                    [pic]so how am i going to check this requirement so how should we modify DFS sothat we can check if there is an edge going out of every sub tree righti am using the sub word sub tree a bit loosely here right here by sub treei mean the the part of that tree which is composed of the descendants ofany vertex rightso take any vertex look at all its descendants that 
# dfs-5
 of the tree iswhat i am calling a sub tree rightthe generic definition of a subtree is slightly different right so how willyou modify DFS to be able to thisso once again we are going to so recall that in the case of two edgeconnectivity we had modified DFS so that it returns to us the deepest backedge right the the arrival time of the ndoe to which there is a back edgefrom the sub tree and the smallest such arrival time [hindi] right in thecase of two edge connectivity what we have done was that we would returnfrom every sub tree would return the deepest back edge by that we mean bythe arrival time of this ndoe yeahnow we will do the same thing here this DFS would return to us the not thedeepsest back edge anymorethe yeah the node with the smallest arrival time to which there is an edgefrom this sub tree rightso let me right that down DFS returns returns arrival time or returns awhat should i say the the smallest arrival timethe smallest arrival time the the smallest arrival time to which there isan edge to which there is an edge from this sub tree from this sub treerooted at lets say vso DFS v returns this rightwhat i am trying to say now is the following when i do a DFS from v therecould be many edges going out of this sub tree rightlets say there are four edges going out of this sub tree and edge which isgoing out of the sub tree will either be a back edge or a cross edgeforward edge cannot be going out of the sub tree rightit can only be coming in to the sub tree or if it starts from here in thesub tree it will go within the sub tree only rightso now essenatially i am going to look at these four arrival times and takethe smaller amonst them the smallest amongst them and that is the quantitythe DFS we will return to v rightif this this arrival time was a this was b this was c this was d DFS vreturns min of a b c d right b is smaller than a right and d is alsosmaller than c um not clear okay but we will come to this[Refer Slide: 26.45]                                    [pic]this is what we have to return now we have to figure out how we will returnthis thing yeah so how will we return this thing how shouldso its so note that DFS is a recursive procedure right when i do a DFS fromvertex v i as end up doing a DFS from its neighbouring 
# dfs-6
 rightso suppose its three neighbouring vertices here x y and z so i will do aDFS from here i will get this tree lets say i do a DFS from here i get thistreei do a DFS from there i get that tree now this DFS x will return to me DFSx will return something to meso it will look at all the edges which are going out this sub tree and lookat the node this with the smallest arrival time to which there is an edgefrom heresimilary DFS y would return something to me and DFS z would returnsomething to me so what is the value of DFS v going to beDFS v would have a value we have to find out the edge going out of thissubtree so an edge which goes out of this sub tree [student: um] would bean edge going out of here or out of here [student:  um] or out of here butan edge going out of here could end up here itself rightso it is not really going out of this sub tree [student: um we have tocheck it with arrival time of the um then it will not um] and we will alsolook at v of course so from v we will look at the back edges out of v andcross edges out of vso we will basically look at all the edges going out of here all the edgesgoing out of here all the edges going out of here and all the edges goingout of v and take the minimum of their arrival times okay and when willthat okay and when will the edge be going out of this sub tree[student: um] when that arrival time is less than the arrival time of vyeah [hindi] there is an edge going out but [hindi] there is no edge goingout [hindi]so you have to check that [hindi]that is less than the arrival time of v if it is less than the arrival timeof v then that means that the edges going out of the sub tree[Refer Slide: 29.36]                                    [pic]and we are okay if it is not less than arrival time of v then we can stopthe procedure and say that the graph is not strongly connectedso now i just have to right the code for this so what will i do lets callthis a strongly connected rightso what is strongly connected going to do so first it is going to settingup the arrival time of the vertex v yesnow what should i do next right i need to keep track of this minimum so ineed a variable for that [student: um arrival time of um] 
# dfs-7
 so let medeclare some variable what should you call it [student: min] min no min isa um [student: we call it function] for the function so what shall i callityou can't think of a name of a variable [student: um x ]x xyz that's howyou name a variable its okaylets call it xyz so what should be my intial value of xyz be [student:arrival of v ] arrival of v no harm in setting it to this value yeahand now what am i doing what should i write next for all [student: w] wadjacent to v out adjacent is the same as adjacent we are saying adjacentmeans out adjacent hereadjacent to v do do what if not visisted [student: visisted v equals onevisited v equal to one ]some where i have to set visited v equals one soon as i started DFS i setthe visited variable to oneif not visited v then what do i do [student: sc of ] then i do a i do a DFSfrom there or i run this procedure from that vertex w and it will returnsomething to me and i have to update what it returnsso xyz equals minimum of xyz comma sc w yes else else else if visited w istrue if the vertex is w is already visitedso then that means that is either a cross edge or a back edge starting fromv else xyz equal min of xyz comma [student: arrival of w]  arrival of wyeahwhat are we doing here we are looking at the cross edges and the back edgesstarting from the vertex v right and also including that into the mincomputation and now what are minsthis is the end of this for loop [student: sir first we will ] um [student:um if xyz is greater than or equal to ] if xyz [student: is greater thanum] equals arrival v then [student: abort] stop right and we will stop withsaying graph is not strongly connected else we just return yes[Refer Slide: 33.46]                                    [pic][student: this will again have problem ] this will again have a smallproblem for the root  vertex because for the root vertex this quantity willturn out to be zero cannot be less than a zero yeahso that has to be checked we can't abort always we have to just ensure thatit is not the root vertex [hindi]so al most exactly like we did for two edge connectivity questions [hindi]good so how much time does this take [student: um] al most the same time asbreadth first search um as depth first search right  we are just again thesame we are we have one additional variable which you are modifiying 
# dfs-8
 all the time the additional time that we require greatso so as far as applications of DFS are concerned you will see quite a fewapplications can some one tell me what all you have seenapplication of DFS to directed graphs or application of DFS in directedgraphs sorry what are the applications we have seen so far [student: um]two edge connected is not for directed graphs [student: um] stronglyconnected checking if a graph is strongly connected [student: cyclic ]checking if a graph is acyclic yeah and of course also topological sort allthought it is the same as that yeahthere are a lot of other applications i am not going to be taking um up inthis class right any questions so far rightso as a recap lets since we are now going to be switiching topics let mealso look at what we have done for undirected graphs right we actually havelooked at only one application that was for two edge connectivity i didmention that you can use similar procedures you can use DFS to also checkif a graph is vertex connected and if it is plain rightbut we did not do the do those two applications in detail in this classright and um what applcaition did we see for um breadth first searchapplications of breadth first search [student: connected componetnts]connected componenets finding the connected compomnents of the graph andchecking if a graph is bipartite right[Refer Slide: 37.42]                                    [pic][student: shortest distance ] shortest distance also that's just breadthfirst search the label that it returns are the distance the shortestdistance of the vertices from the root the starting vertex rightand all of these are linear time procedures all of these [hindi]yeah 
# avl-0
 TRANSCRIPTION : SRIMATHI                             PROOF READING: BANUMATHI                       Data Structures and Algorithms                               Dr. Naveen Garg                  Dept of Computer Science and Engineering                                  IIT Delhi                                Lecture - 11                         AVL Trees (Time 01:10 min)In this class we are going to be talking about AVL trees in the last classwe have seen binary search trees data structure now one problem with thebinary search treeif you recall is that the operations of insertion deletion search all ofthem take time proportional to the height of the tree height of the treecan be very bad ya we saw in the example with the height of the tree couldbe as bad as order end or n minus oneso we want to some how created tree which doesn't have to bad a height andthat's what we are going to do today we are going to look at the datastructure call avl trees okay what is an avl tree (Refer slide time 01:58)avl tress are what are also called height balanced trees okay now ignorethis white spots that are showing here they should not have shown here[pic]this is the binary search tree these are the keys inside the nodes of thekeys right everything to the left of the root is everything which is lessthan to the root is left of the root is everything which is more than theroot is to the right of it now what have also written next to each node isthe height of a node now what will we call the height of a node we will notdefine this turn end we will just say the height of a node is the height ofthe sub tree rooted at that node yaso for instance if i look at this node this is the sub tree rooted at thisnode right what is the sub tree rooted at that node is a just set ofdescendentsso i am looking at this tree now now in this previous classes we havedefine the height of such a tree as two and not three because we had saidthat this has this is level zero this is level one this is level two and sowe had call this is height of the tree as twonow we will just modify this we will say that if it is the single turn nodejust one node it is a height one instead of height zero as we will becalling it this sub tree has height two so level numbers are not beginninglet say with one okayso this has height two this has height this sub tree has height three andthis entire tree has height four okay ya so we are going to call this asheight of the tree for let us say the purpose of the avl treeso with every node i put down height of that node so what is the height ofthe node it is just height of the sub tree rooted at that node ya so thisis height one because that is nothing below it this is height one this isall the leaves will have height one the parents of the leaves will haveheight two and so on ya now such a trees called avl tree if it is heightbalanced what is height balanced means if i look at any node and i look atit children than the difference in their height is at most one there mightbe no difference in their heights as in the case with this node its twochildren have the same height this node has the difference the left subtreehas more  height than the right sub treethe left sub tree has the height two and the right sub tree has height onethis also has a difference of one the right sub tree has height three nowand the left sub tree has height two yabut the differences is no more than a one right so this is the avl treethis is what our definition of an avl tree would be yes it is true forevery node of the tree is there is a binary search tree so there are twoproperties it has to be a binary search tree and if a every internal nodeof the tree the heights of the children differ by at most one by away saidinternal well for a leaf node it has no children it doesn't make anyincidence to call to talk up the height of the tree right so for this nodethe right sub tree has height one and sis 
# avl-1
 left sub tree is missing wecall it height zero so now you understand why i had made this change todayright absence of the tree i will note i will call it height zero yaand now single node will become height one and what ever right so that'swhy i shift the definition everyone okay with this ya let see what is not atree what is not an avl tree [noise]once again that we just okay let me just switch over to the thing um sorecall that one of our binary tree is which was very bad was which had ahuge height was the tree like this yes right (Refer slide time 07:22)[pic]this is a binary search tree i kept put some keys so that it looks like abinary search tree and this has height equal to n minus one if there were nnodes yes is this an AVL tree no is this node height balanced yes it is aleaf node write is this node height balanced this is also height balancedis this node height balanced no because the right subtree has height twoand the left sub tree has height zero so this has height two and this hasheight zero so this has height balanced properties violated here its alsoviolated here and its also violated hereso we will never have such kind of trees as AVL trees (Refer slide time07:24) ok good so lets trying figure outs since we since we said that weare not going to have such kind of trees as AVL trees lets trying thefigure out how bad the height of an AVL trees can be ya [noise][pic]so let say i have an avl tree of n nodes ya if its height can still we asbad as n minus one i am not gain anything so i am not gained anything so iwould like to say  something like its height is no more than log n orsomething we will figure that out so that's what we are going to say thisis what we are going to prove in lets say in the next few minutes theheight of the avl tree t which has n nodes in it is only order log in okaylet see why this twoso i am not going to prove this claim directly i am going to make a smallslightly different argument right i am going to say let us take an avl treeof height h amongst all possible of avl tree of height hlet me see the one which has the smallest number of nodes so define thequantities n of h here as the minimum number of nodes in an avl trees ofheight h and lets us figure out what is the quantity and than we will seehow this implies this proportion here okay so you don't know understandwhat i am sayingso given an avl tree of heritage we want to find out what is the smallestnumber of nodes it has can it have only h nodes than we will be in troublewe want to say many many  many more nodes right if you recall a binarysearch tree on h nodes  of height h can we have only h plus one nodes rightthis example that i showed you which was applied but a good tree which islike a complete binary tree of a height h will have two to the h nodesright what would you really like that is of avl tree which was of height hhave a large number of nodes not just h but more like two to the hsomething like that ya and that's what we are going to prove (refer slidetime:11:31)[pic]Okay so what let us understand what is the quantity so it's the minimumnumber of nodes in an AVL tree of height h so if i take an AVL tree ofheight one what is an AVL tree of height one just a single ten node nothingelse okay it has only one node in it if an AVL tree of height two rootedone node but it can also to be rooted two children right so why i havewritten two here and not three minimum i am counting minimum right sothat's why end end two equals two the minimum number of nodes will be justtwo in an AVL tree of height twoso suppose i have an AVL tree of height three or more so it will containone root node so suppose AVL tree of height h it will contain one root nodeit will have an AVL tree of height h minus one on one side and an AVL treeof height h minus two on the other side why h minus one and why h minus twookay some one tell me well it has height h so its children its children canhave height only h minus one not more than h minus one rightso they can have a difference of at most one so if one of them is h minusone the other one can only be h minus two or h minus one right so one ofthe subtrees has height h minus one and other sub tree has height h minusone or h minus two but what will be the pick we would like to the other subtree have height h minus two why minimum number of nodes so at tree whichhas smaller height will also have smaller number of nodes so we would likethat the other sub tree have h minus two height yaso if n of h was the number of nodes in the tree of 
# avl-2
 h than what isthe number of nodes n of h equal to it is the number of nodes in a tree ofheight h minus one the smallest possible because we would like that theleft sub tree which is of lets of height h minus one in the right sub treewhich is of height h minus two the h minus one sub tree have as small aslittle number of nodes as possible and the h minus two sub tree also aslittle number of nodes as possibleso the number of nodes sorry the number of nodes in the left subtree is nof h minus one the number of nodes in the right sub tree n of h minus twothere is one root node so this is what the recurrence relationship looklike rightonce again we have seen the recurrence relation every one satisfied withthis ya  so this is what we have to solve today ya and what are the basecondition we know its  n of one is one and n of two is two right with thatyou can figure out what a n of three would be n of three would be one plusone one plus two four ya and so on and all but you would like a close formexpression to be able to do this so we will solve this recurrence okayso we are not going to be solving this recurrence exactly okay we are goingto run approximately so first we use the fact that (Refer slide time 16:34)n of h minus one is only going to be a larger than n of h minus two rightbecause as the height of the tree grows the number of nodes cannot reduceright it will only be more right so n of h minus one is atleast as largestas h minus two and than this implies that what we had written earlier n ofh equal to n of h minus one plus n of h minus two plus one this quantity isat least as largest two times n of h minus two strictly large because ialso drop the one ya[pic]i will place this n of h minus one by n of h minus two and this is what iget ya now this is becomes the simple thing to solve n of h is more thantwo times n of h minus twothis is what i solved so n of h is more than two times n of h minus two yaand now n of h minus two is more than two time two times n of h minus fourso this implies this entire thing is more than four times n of h minus fourwhich implies that the entire thing is more than eight times n of h minussix ya you understand how this comes n of h minus four is more than twotimes n of h minus six and so on and on which will eventually take as tosomething like two to the i after i steps n of  h minus two i ya greatokay so suppose i pick i equals h by two minus one i am going to assume fornow that this quantity is an integer ya so let as assume h was even tobegin with so this is an integer and for this value i will get two to the hby two minus one n of h is more than more than two to the h minus one timesn of so i am replacing i by h by two minus one so i get a two here yes soits n of twon of two recall was two so it becomes two times two to the h by two everyone is be  so what is this say we just argued that if your AVL tree hasheight h than it has atleast two to the h by two nodes at least so manynodes right what is the maximum number of nodes it can have two to the hsomething like two to the h either two to the h or two to the h plus oneone of those ya because it can be a complete binary tree yaso now suppose i would have to take algorithms what would i get i would getthat h is less than two times log of n yes right so if i have in AVL treeon n nodes so right so n of h is actually less than or n rightbecause i have an AVL tree whose height is let say h and it has n nodes sosuppose i had an AVL tree of height h and n nodes than it will also satisfythis relation yes it will satisfy the relation because n is only going tobe larger than n of h n of h what was n of h h was minimum possible numberof nodes ya so any AVL tree on n nodes and height on n nodes has height atmost login two login from this example from this argument is it something you did not follow are you confused about this n of hright so this is what we argued after taking algorithms now let me take atree of height h and n nodes ya so n is going to be larger than n of hbecause n of h is the smallest possible is the minimum number of nodes thatare possible in a tree of height h n of h is that quantity [noise] this isjust a function don't confused this n with the number of nodes you canreplace this n with 
# avl-3
 else[student:noise]staff: n of h is the minimum number of nodes in a tree of height h[student:noise]okay if you are getting confused lets let me just clarify this [noise] sowhat we argued here was that h is less than [Refer slide time 18:47] twotimes log of n of h ya okay[pic]now take an AVL tree of height h and let say let me not call it m let mecall it m nodes yaso its height is h it has m nodes in it so what does this implies m isgreater than n of h this follows from our definition of n of h m is morethan and we know that h is less than two times log of n of h which is thenless than two times log of m this implies h equals big o log of m yathe height so what was this this was height this was number of number ofnodes the height of an AVL tree on m nodes is less than two times the twotimes log of the number of nodes is this clear nowso the m and n confusion is (now) great so that's what being said here anyquestion to this pointya so we shown that such a tree will have height no more than two log n thebest possible tree can could have height only log n right if it were like acomplete binary tree very dense and every thingbut this has this has more height but not two much more just a factor twomore much better than having a height of an n greatso lets try and solve this recurrence slightly better this is more of anexercise also to to show you how recurrence is solved rightso we did fairly crude analysis here right we replace this with this n of hminus two and then we did this and we got this this trying get somethingbetter right just as just as an exercise(Refer slide time 21:19)[pic]so we will show how to get a sharper bound on the height of an AVL tree[noise hindi 20:07] the bound we right now two times log of n let see if wecan get something better than thatso we were use an induction and we are going to do a tight analysis of thesame thing we are going to show that the minimum number of nodes in an AVLtree of height h which was n of h is at least c times h now we are going toshow it at least c times hwere c will be some constant more than one what did we shown in theprevious slide it was atleast n of h was at least [noise] two to the h bytwo two to the h by two so what was the c root two two to the half to the hright so there we showed a c of root twolet see if we can get a bias c right larger c more than root two right andwhat would be the way of such a thingso we will assume that n of h is atleast as larger c to the h let see whatwe can argue where okayand we are going to be prove this by induction and we will figure out whatthe  c is laterso i am we have proving a certain statement without actually knowingexactly what the statement is because i am not telling what the c is butyou will see what the c has to be for the statement to be true right whatis the base case h equals one h equals one pay n of h is one we want thatso so this statement would be true this statement is true at h is equal toone right no just once again what we have said we have said the number ofnodes is going to be at least as large as [noise] okay let us come back tothis in the minuteso i assume to i made a mistake let us come back this base case again letwe will have to perhaps redefine the height of a tree here okaylet i thing may we should we should have c of h minus one or some suchthing okay we come back to thissuppose the claim is true for all h less than k and lets try and prove itfor h equals k notso far we have to prove that n of k is greater than or equal to c to the kokaywe come back to this base case in a minute okay so the recall (Refer slidetime 25:16) this was our recurrence relation n of k equals n of k minus oneplus n of k minus two plus one and induction hypothesis says that n of kminus one is at least c to the k minus one n of k minus two is at least cto is strictly larger right i just ignore this plus one again okay[pic]now i have to show that n of k is larger than c to the k i can show that nof k is larger than c to the k if i can show that this quantity is largerthan c to the k yaso this is what i have to show i have to show that c to the k minus oneplus c to the k minus two is lager than c to the k yes right okay goodso what should cb so that this is true well i just cancel out termsappropriately and i get c square minus c minus one should be less than 
# avl-4
 to zero if c satisfy this then this will also be true yes why becausei just multiply both side by c to the k minus two and i would get exactlythat and if this is true then n to the k which is larger than this wouldalso be larger than c to the k right i just have to pick a c which satisfythis right and you can you all know how to figure out c which satisfy thisrightso we will just solve (refer slide time 25:16) this quadratic equation thishas roots right one minus root five by two and one plus root five by tworight this is negativeso anything in between would keep this less than zero rightbut i wont as large as c as possible so i will take one plus root five bytwo which is roughly one point six three and this quantity is also known asthe golden ratio okay so we will we will see this more often perhaps[noise] we can solve what exactly [student:noise]no no this is not a fibonacci relation [noise] if you add one to both sidesright okay goodokay good okay okayso you will get n of k would be with the fibonacci number minus one good yayou can also do that right so we get bound of roughly one point six three cas one point six three right so what is the mistake we have made so onething is a base case have not worked out right so i guess this was thewrong thing to pick it should not be c to the h but may be c to the h minusone rightso induction hypothesis should be c to the h minus one (refer slide time26:28)[noise] right so let us take c to the h minus one we will not make adifferent right so we take c to the h minus one you will not make adifference right so we take the c to the h minus one so precisely i amdividing out by c then the base would have also be satisfied if h equalsone you would have more than one which is a case ya[pic]and so sorry about this and for the other two also it will be okay yabecause h equals to twon of two is two and this would become c to the two minus one which is c cis less than two because we just argue it is one point six three (referslide time 28:05) okay[pic]so please make that correction [noise] we really require that the inductionhypothesis is h minus oneit will not make any difference on this how ever [noise:hindi] k minus oneif this become h minus one this will become k minus one right this wouldthis continue as it is right this will become k minus two plus ck minusthree we have to prove this is greater than equal to c k minus one everywhere there will be a minus one so that you will still get the samequadratic in equality ya so the value of the c would still turn out to besame [noise:student]one point six three to the power k minus one h minus one n of h minus oneya so please make that small correction okay and so you will have that theAVL tree on n nodes has height now log of n to the base one point six threethis quantity okaybecause what are we said we have that if i take a tree on n nodes the sameargument is before so we just see do the same argument as before we have itake a tree of height h and [refer slide time 29:44] n nodes ya so we havejust seen that n of h is greater than or equal to one point six three tothe h let say minus one that's what we saw just now this is the tree withsmallest possible number of nodes so n is going to be only larger than thislet us take log of both sides[pic]so we get log base one point six three n equals h minus one i am just usingthe definition of log i am taking log to the base one point six three ya soi will get this this implies h equals log of one point six three n plus oneit will okay rightso we have been able to prove this kind of a sharper bound ya[noise:student] this equation does not satisfy n equals two it does okaygreat it also works for n equals two right so that was our base caseso every one agreed okay great so lets continue so i have shown you twoways of solving this same recurrence right one was the much simpler wayactually both are very simple rightso the second technique is is also used quite often you make a guess onwhat you think it should be derived value should be right and thenessentially verified that to be said suppose to be right value that some cto the h and then you figure out what you see should be and you getsomething better right so earlier we had root two one point four one fourand we could [ ] one point six three by using this [ ] techniqueokay so lets look at the structure of an AVL tree in a little bit moredetail (refer slide time 31:20) right[pic]so i once again have an AVL tree on n nodes okaynow let me take the leaf that leaf of this tree which is closest to theroot which means at it whose level number is as small 
# avl-5
 possible thesmallest among to all the leaves suppose this leaf is at level k okaywe can show that the height of the tree is at most two k minus one is thisclear no this requires the proof and lets do that [noise] okayso whatever said i have an AVL tree (Refer slide time 35:45)which has nnodes in it although this is not going to be a particularly important thenumber of nodes in that tree so this is some tree okay i took that leaf ofthe tree which is closest to the root right suppose its this leaf herewhich is closest to the root and we said its at level k right so the otherleafs could be at this level or could be below [noise:student][pic]no in this class for AVL tree lets say we work with level starting onedoesn't make a big difference lets say we start with level one we are goingto prove that the height of this tree is at most  two k minus one so heightof this tree is less than or equal to two k minus one that's what we willprove let see whyso i will draw this picture again here okay so this is the leaf i will letme color it red which is at level k and which is the one which is theclosest to the root right from this node there will be some sub treehanging out from this node ya from this node also they will be some subtree hanging out and so onthis is my root level zero level one sorry [noise] um now lets look at thisnode first which is at level k minus one what is the height of this nodewhat can be the height well it has one child this child has height one thishas height one so the heights are in blue ya so this means that this subtree can have height at most two rightso we want to get as large height as possible for this tree right sowhenever we say at most two will just take the largest value rightso this can have height two so if this has height two what is the height ofthis node this sub tree will then have this sub tree will then have heightthree ya this sub tree will have height three if this sub tree has height three what is the largest height that this subtree can have four so what is the height of this node fiveso what is the maximum height this sub tree can have know six and so thiswould be seven and nine and so on right so what will the root have heightnow no in general given that this was k yaso well right if ya just figure it out it should be two k minus one rightif if it was just still up till here its basically k two height three sowhen k if k were two this was the picture then the height was three if kwas three this was the picture height wasfive if k was four height was seven and so if for arbitrary k this is two kminus one ya very simple argumentso which means that this entire tree can be no taller than two k minus oneif the closest leaf was at level k this is the property of AVL tree is nota property of any arbitrary binary tree yes you understand that right in anarbitrary binary tree you might have leafs at any level (Refer slide time37:03)[pic]but the height of the tree could be as bad as you want it here is a leaf atlevel one but this height [noise:hindi] but for an AVL tree if there is aleaf at level k that height of the tree can not be more than two k rightso an any AVL tree is basically if there is a leaf at this height if thereis basically all over leafs now will be in this part only this band whosewidth is as larger this roughly right this was k and this was also k k kminus one i mean during thatya i will come to back to this in a minute okay so we just argued (referslide time 37:35) that if the closest leaf is at the level k then theheight of the tree is no more than two k minus one that is the largestpossible height the tree can have okay now lets make another claim (referslide time 39:13)[pic]if the closet leaf is at level k then all nodes at level one through kminus two have two children ( )every node on this first k minus two levels have to have two children rightand why away said k minus two and not k minus one [noise: student]so lets prove this by contradiction so what do we want to do contradict solets take some node at level k minus two  which has only one child rightthis is the picture i have node u level k minus two it has only one childwhich is at level k minus one right i have shown know node at level k minustwo but the same argument would applied to any node at one through k minustwo ya so v is at level k minus one so it cannot be a leaf because theclosest leaf for that level k right good yaso it has to have another child i have shown only one but it can also havetwo children no rightbut this guy u has only one child so sub tree rooted at 
# avl-6
 has height atleast two yes because this has have two this has to have one child itcannot be a leaf so it has height at least two while the the right sub treehere has height zero because there is nothing thereso we have a height imbalance at this problem at this node so the heightbalance property is violated at uyes so every node on this levels one through k minus two have to have twochildren at level k minus one how ever there can be nodes only one childthat you understand right everyone understands that [noise]this is level k of course (Refer slide time 40:58)the tree extends this isthe level at which the closest leaf is at level k minus one i can have anode with only one child and that child is this lets see here right[pic]this is okay provided this guide is not have any more descendants and neednot have because it can be a leaf rightso this is completely okay but if it have more descendants then we wouldagain have a problem height balance property yaso this is okay so which means that this guy can have only one child buteverything here has to have at least two children okay great so so we said(Refer slide time 42:24) every node at level k minus two has to have twochildren so which means levels one through k minus one are full full meansthey have as many nodes as a possible on level on that level in a binarytree this will after all a binary tree okay so they are full[pic]so what is that mean that means the tree has at least two to the k minusone node ya we also argued we recall that height of the tree is at most twok minus oneso if the height of the tree is two k minus one then it has at most two tothe power of two k minus one nodes yathis implies the number of nodes in the tree which was n is between two tothe k minus one and two to the two k minus one yaeveryone agree so suppose since we have been using h for the height rightlets substitute h for two k minus one lets see what the equation is looklike this becomes two the h and this becomes two to the h minus one by twothis is the same thing i am showing you over and over again what is thething if you have a tree of height h an AVL tree of height h than it has atleast two to the h by two nodes we had shown earlier rightso now we are showing the two to the h minus two just roughly the samething square root two to the h nodes all though we proved the sharper boundi am coming back to the older bound the point is it has an exponentialnumber of nodes it has number of nodes which is some constant c to the h anexponential right because that's was give as the logarithmic heightproperty rightso this is actually a third way of proving that the height of the tree isonly login right you can also use this as a proof rightso this did not require solving the recurrence relation that the two methodwe solving the recurrence relation the shop is long we were see so far is cto the h one point six to the hso lets summarize(Refer slide time 45:31) what we have seen as thestructure of an AVL tree is concerned if the height of an AVL tree is hthen the closest leaf can be at level h plus one by two right[pic]i have just change things around when i said when the closest was k thanthe height was two k minus one so i just change that around as if theheight is h so suppose i give you an AVL tree and n nodes of height h thenthe leaf which is closest to the root is actually pretty far from the rootits atleast half the height away is at least h plus one by two away yait doesn't require a proof its just i am just rewording what i have saidearlier we also saw that on the first h minus one by two levels the AVLtree is it complete binary tree lets this what an AVL looks likeessentiallyfor the first half of half levels its complete very dense ya and then itsstarts thinking out right as its stars so it turn the tree around so withthe root at the bottom so initially its denseand then it kind of things to the full height okay but this part the factthat it is very dense for the first edge by two levels means at it has alot of nodes it is a complete binary tree so it has two to the edge by twonodes straight away ya and that means that the height can not be too largeif i had had n nodes the height can not be more than log n two log n rightso once again i have said that if number of nodes in the AVL tree isatleast just on this fact since it is a complete binary tree on h minus oneby two levels it has atleast two to the h minus one by two and at most twoh nodes because that is the height of the treethis is the useful structural fact to keep in mind about AVL trees althoughwe will not use it for any of our algorithmsbut it just 
# avl-7
 you some intuition of what the tree is in wise it thatthis tree has only a logarithmic depthya so now we looked at this height balance property right we said you knowif this height balance property is there then then its nice the height ofthe tree is only lgorithmicand so now we want to say that all our operations are only logarithmicbecause we still want to say that you know you can do a search in certaintyin log n timeso search is easy there is no problem with search right because after its abinary search tree right forget the height balance property its just abinary  search tree so you just do search as you do in a binary search treehow much time will you take proportional to the height order it height islog n so you will take it only log n time ya great thats the best you cando in some sense oknow suppose you have to try an insert right (Refer slide time 49:16)supposewhen so you work when you are going to do an insert what what can go wrongso recall that we we call this height balanced that treat to be heightbalanced[pic]if the difference in the heights of its children is at most a oneso when i insert a node it can change the height of some nodes ya and as aconsequence the height balanced property may get violated okso when i insert so insert will be the same the first step of insertionwould be the same as we did in the case of a binary search tree yahow did we insert in a binary search tree can someone tell mefirst you find the position how do you find that element will you justsearch for that element that you are trying to insert that will tell youwhere the position is and just put the node there put the node there andthen you start marching up back to the route by following the parentpointers okand assume march up you keep updating the heights of the various nodes youencountered because these are the only nodes whose heights could havechanged no one else yesso these are the only nodes whose height we will look at this again in moredetail perhaps in the next class i am just giving you the flavor of whatneeds to be done when we are doing an insertion so these are the nodes atwhose height will going to changeso we will going to the first place where  height change appears whereheight imbalance happenswe are going to only start from the node where we inserted and move up thetree towards the route so basically keep going parent parent parent parentparent tell we hit the route and on this path that we follow we find thefirst node whose which has the height imbalance property rightso suppose that node is called z and its grandchild is called x oklet me skip this part and wise up node in whichso let i think its best of(Refer slide time 51:13)   show your picture andthat will give you an idea[pic]so suppose this was my tree right forget this empty node for now this wasmy tree originally rightif this will my original tree is that in AVL tree height balance issatisfied here because this is one this is one this is not there thisforget this type of node rightthis is also height balanced because this is two and this is one this isalso height balance this is one and this is zero this is height balancebecause this is two and this is three initiallybut now suppose i went an certain a node lets say fifty four which came inhere ya fifty four would come here i go right here left here right here andleft here now the height balance property is violated so what i am going todo this i am going up the tree towards the route is the height balanceproperty violated here no its not rightso this is one this is zero is it violated here no one two this is heighttwo this is height one is not violated here is it violated here yes becausethis is now three and this is one so these numbers are the new heightsright this is threeso this is the first node at which the height balance properties we callthis nodes  its child will be y and its grand child will be x we wonderwhich child of this node will be y will the child on the path that we takenand now we need to do something to this tree to make it height balancedagain this is not height balanced tree right all the things we said aboutlog n and all we go out of the window if you leave the tree like this rightso what we are going to do is we are going to rotate do a kind of rotationoperation and this will become my new tree ok so in some sense what i havedone is a kind of move this up move this down and this fifty was here rightit looks a bit mysterious here so that's what we are going to do in thenext class right understand how this rotation operation is done so i cansee now the height balance property is not violated at any nodeya so its not clearly here its not here its not here both of them areheight two this also this is height two this is height three and this isheight two so its not violated this is still 
# avl-8
 binary search tree with the same keys as before we willnot change the keys right there are other ways also right but this is youknow you want a an automated way of doing it right you should not have tolook at the you know you don't have to draw the picture and then figure outwhat rotation have to be done right so you will be able to do this programso this is what we are going to do in the next class look at insertion lookat how to do this rotations so that the height balance property is retainedeven after insertion so look at both insertion and deletion in the nextclassso in todays class we looked atAVL trees we saw what how AVL trees are defined and crucially we saw thatthe height of an AVL tree is no more than actually we proved a bound of logn to the base one point six three today rightwe spend a lot of time figuring out how to solve that recurrence relationsso we saw two ways solving that recurrence relation we also look as somestructural property of the tree which also proved a similar bound and theheight of the tree ya so we that will end today's class 
# 24trees-0
 TRANSCRIPTION : SRIMATHI                       Data Structures and Algorithms                               Dr. Naveen Garg                  Dept of Computer Science and Engineering                                  IIT Delhi                                Lecture - 13                        (2,4) Trees (Time 01:10 min)in today's  class we going to talking about to two four trees this isanother way of representing (additionally)so we are going to see operation of insert search and delete on this datastructure and we are going to have same kind of performance guarantee aswas the case in AVL treesbut we us going to in later classes see how this data structure is usefulso today I am just I will just begin with thisso what are two four trees (Refer slide time 02:10)[pic]they are search trees they are kind of search trees but they are not binarysearch treesso recall in a binary search trees what was happeningthe tree was a binary tree yaeach node at two at most two children rightso this not going to be a binary tree that's a first pointso nodes can have more then two children nowso this two four trees are also called two three four trees rightI will tell you what this really needsso two three four actually refers to the number of children and node canhaveso node can have either two three or four children rightsuch trees in (Refer slide time 04:43) which node can have many childrenbut satisfy a certain kind of search properties or called multi way searchtrees right[pic]so each internal node of a multi way search tree has at least two childrenrightso besides the child so it will have so at leas two which means it couldhave more then two children right any number of children more then twoeach node of tree also stored a collection of items the form key comaelement rightso just as a binary search in the binary tree in a binary search each nodewas storing one key and the element there was lets say reference to theelement or the element itself could be stored there rightif the key was lets say student record student entry number the studentrecord as you said the key could also be stored in the node itselfso in the similar way we have that in the multi way search tree you willhave each node containing a pairs of this kindkey comma element and how many pairs there could be more then one rightin the binary search tree there is only one such such pair and each nodeand in a multi way search tree there could be more then onein particular there could be d minus one search pairs or items right whered is the number of children that particular node has rightso just as so we just as generalizing a binary search treesin the binary search trees there is each node has two children yaeach node could have two children and then there is only one keys that isleft kept in the nodebecause that keys helps us helps us determine if we should go left or rightsimilarly here we have d children (Refer slide time 04:43)d is the number of children then you really needs to know in the searchprocess whether you should go to the first child second child third childfourth child and so onso you will have d minus one difference keys sitting in the node to helpyou determine thati will soon showing the example and that should clear with that right and Ithink I come back to this after I show you the example (Refer slide time04:43) okayso this is an example of multi way search tree okay[pic]as you can see this node has two childrenthis has three children this node has two children this has actually dchildrenso sorry this is actually six children ya  okaynow how many keys are there in a nodethe number of keys in a node is one less the number of children in thatnode has  and why is 
# 24trees-1
 yaso for instance this node has three children and you read need two keys inthe nodethe key is determined you know the keys in the node determined what set ofkeys the various sub trees are going to have rightso what I am trying to say here is this is key twenty twoso everything in this sub treeso this sub tree is actually this is also in the left sub tree here yaso everything in this left sub tree here is less then twenty two andeverything here is more then twenty two yesis just clear everything here is more then twenty two and everything hereis so if you look at this key everything to the left of this is less thenfive everything more then ten so in the right sub tree so we now have threechildren rightso in this first sub tree everything would be less then fivein the last sub tree everything will be more then ten and those in betweenfive and ten would  lie in the middle sub treeso that's a concept rightnow you understand why you need d minus one keys if you have d childrenrightso everything less then the first key would been in the first sub tree forthat you have to follow in the first childeverything between the first key and the second key you will have to followin the second child and so on and on rightso with (Refer slide time 04:43) that let me go back to the previous slideso the children of each internal node are between this items rightthis is what I mean by between in codeso you have certain node it has various keys or itemsso if you look at two consecutive keys then all the elements all the itemswhich have key value between the consecutive pairs would be in one sub treefor that you will have to follow one child okayso lets get back to thisthis is an example of an multi way search tree right and how do you searchsuch as tree(Refer slide time 09:25) searching is similar to the binarysearch procedure as you did in the binary search tree[pic]so suppose we are searching for eight you come down here compare eight withtwenty two eight is less so you go herenow you will have to find so eight is not less then fiveeight is not more then tenbut eight lies between five and tenso you will follow this and then you will find that eight is sitting hereso it's a success visit rightso when you searching for a key s you will compare it with k onek one is lets say the very first key in that node and k lets say k d minusone is the last key in that nodeso you compare it with the very first key if it is less then that means yougo to the left most sub treeif it is more then k d minus one then you have to go to the right most subtree okay08:34so when you searching for the node for instance when we searching here forfor eight we came down we went left because eight is less then twenty twoeight lies between five and ten so we came down here and then we foundeight here rightso while we are when we are searching for twenty two we came down thesequence of steps and we found the twenty two was not yet sorry twelve yeswe found that twelve was not yet okayso in particular when you (are at) 09:08 a node you have to determine thatthe key that you searching for which two keys is lies between right andonce you determine that and you will follow the appropriate child nowat the two extrimate is you will check whether it is less then the firstkey or its larger then the last key which keys is should follow either itleft most child or right most childso as simple as that so what would in order driver in traversal tree looklike that was the question we were at okayso first what is the in order traversal in a tree so we recall in ordertraversal says left then you print the data of the data and then you goright but now there is no left and right a because a node can have manychildrenso what should in what does an in order traversal here here mean rightso first go the left most then print the key then go to the next child thenprint the key then go to the third child then print the key then go to thenext child and so onright that would correspond to in order traversal rightso for instance in here if I have to do in a in order traversal (Referslide time 11:45) what would I do[pic]so first I would print twenty two no not 
# 24trees-2
 twenty two sorry what wouldfirst I would come down here first go left I will first do an in ordertraversal on this part of the tree ya which means at first come in here Iwill first go left I will do an in order traversal here which means I comein here I first go left but there is nothing so then I print the key that'sthree then I go to the middle child nothing thereso then I print the next key fourthen I go to the right child nothing thereso that finishes in order traversal on this nodeI have finish the in order traversal on that node I go back to the parentright and then I will print this key ya because first I went left then Iprint the key which I print five then having printed this key I will nowdoing in order traversal of this tree this sub tree this sub tree hereso when I doing in order traversal of this I will get six and eight havingfinish that I go back print this key nowit gives me ten and then I will do in order traversal of this right subtree here right and that would give me eleven first thirteen fourteen andthen all of this yaso seventeen eighteen nineteen twenty twenty onenow I finishes the in order traversal of this entire thingso I print the key twenty two and then I go right so we can see you willget the keys in sorted order that's see also easy to prove whybecause in an in order traversal I will first print out all these keys andonly then  will i print out these key rightso which means that in the order of printing all the keys which are lessthen this key will appear before and all the keys which have more then thiskey will appear after and this is true for every key so which means thatwhat you get in this sorted order okay ya can a node which have more thentwo keys yes six eight  put more then other children also for instance Icould have something some other here lets say five point five ya five pointfive would be a valid node here instead of this I could have just one nodewith five point five here yes yaso that of course we can we could organized in a different mannerbut five point five is a valid node here right there could be a more nodeshereokay greatso now lets understand what two four trees okay so two four tree is (Referslide time16:28) something like this[pic]what are the properties each node has at most four childrenso first it's a multi way search tree okay multi way search tree which meanevery node has at least two children yanow we are seeing each node has either two three or four children that'swhy its called two four tree or two three four treeeach node has atmost two has two three or four children the secondimportant property is a all the leaf nodes are at the same level rightso the leaf node here are this just forget this square boxes for nowso these are the leaf nodes and they are in the same level they are all atlevel suppose we are numbering level zero one two againso they at level two right so these are the only two properties of the twofour tree of course it is multi way search tree so that is two four tree isa multi way search tree with two addition propertiessearch tree a it will have a properties that everything which is less thenthis key is going to be in that left everything that is more is going to bein the rightthis is an example of an two four tree as you can see this node has threechildren and this is two there is no node with four children but you couldalso have a node with four children in ityes its clear to everyonewhat is the height of an two four tree nodeokay don't read from the slide tell why should the height of the tree theat least log in to the base four and at most log in to the base two rightso what is the worst case when would height of the tree be maximum[noise:student]when everyone has two children right and when its in that case everyone hastwo children and all the leafs are at the last levelthen its basically its exactly a complete binary tree and complete binarytree we were argued with the height is login base two there was plus oneminus one some where while forge where it was but its some thing like thatrightlogin base two that's a setting when the tree height is maximum the treeheight is minimum when every node has four children in it yabecause then 
# 24trees-3
 nodes are closer to root right you have four and thensixteen and then next level and then four to the sixteen to the four at thenext level sixteen time four sixty four at the next level and so on and ofyaonce again if we do the same analysis you will find the height of this treeis login to the base fourso height of the two four tree on n nodes always lies between these twoquantities yaits either login base two its lies between login base two and login basefour login base four is essentially half of login base two yesso basically the height of the two four tree lies between half of login andlogin okaynow you can tell me how much time it takes two for search how much timedoes it takes search for the two four tree then umwhy loginhow do we search in a two four tree it's a multi way search tree right soif I am searching for a particular key lets say suppose what do I want tosearch I want to search for eleven lets saysuppose I want to search for eleven once again I want to search for elevenI came here with eleven like where would i go compare eleven with twelvelike come here right I will change color eleven I am comparing with ten soI go right and then I find eleven hereso found eleven yaso how much time it doesn't take for me too search in a two four treeheight of the tree is it something more that need to do rightit is correct it is order height of the tree I have to compare with in eachnode right because when I am searching for eleven after essentially nowcompare against how many keys there could been in a nodehow many keys there could be in a node and node we said has how manychildrenfourif it has four children how many keys ( ) it have threethe maximum number of keys therefore is three if it has two children howmany keys do a require one right node has either one two or three keys sowhen I search for the key and I come with key then I have to compare itwith this node with this key with this key and with this keysome what require three comparison and all rightto determine which particular branch to take out some what require threecomparisonso that time three comparison with in a node times login because that'slogin is a number of node I would be given to order login yaso order login is correct but you have to careful about thisright within each node you require more then one comparison is in a binarysearch tree you required only one comparisonbut now you could require up to three comparison greatwhy three loginso he is asking me why we did I say three loginwhen I am searching I start from here ya start at the root and thenwhatever key I have with the key is a node here this node has only one keybut it could have three keys in itthen I have to compare again each of those three keys to determine whichparticular branch to take out of that node right if it has three keys thenthere are four different branches which should I take to determine that ifit make three comparison greatso now lets look at insertion in a two four trees (Refer slide time 19:43)[pic]so I am I have largest example that I am going to be using to show you theprocess okayso is it a two four tree this has four children this has four this has twochildren this has two children and the last one is also have two childrenI have shown the node with three location in it rightso in each node will have space for three keys right and for four pointersso it has only one key but I am shown each node has having space for threeokayso first element I am going to insert as twenty oneso how do we insert we insert just as in the case as in the case of thebinary search tree rightso first we will search and wherever our search terminatesif we found that element then it would say that okay its already exist youwill not insert then rightbut wherever the search terminates we would insert element is so lets seetwenty one I am trying to insertso twenty one I come and compareso here twenty one lies between thirteen and twenty two so which means I amgoing to take this branch outso take this branch out I compare against the eighty its larger theneighteen so i am going to take this branch outso take this and goes and sit that particular node yawhy does it go and sit this nodewhy did I compare with 
# 24trees-4
 twenty and say okay let me go down further yathis is a leaf noderightif i when I hit the leaf node you know if I okay I could also said it okayI compare it with twenty then I try to go right but right node is empty theright pointer is no its null pointer because its not going to any furtherso I know that this is the place where I have to insert and this is emptyand there is space here so I just put it in[noise:student]no we would not put it in next to eighty we would continue till we cant goany further this is what happens in the binary search treeright[noise:hindi] till you heat the null pointer and then you put it thereso till we heat the null pointerso we comparing twenty one with twenty lets say we were trying to go rightbut this is a null pointer and so we put the node here okaynow you wound ring how am I going to use this page we will see how we aregoing to use this page what was if this was already filled [noise:hindi]you will have to wait till the next slide not next week but next slide okayso there is empty space no problem you can do the insertionlets say now we try to insert the twenty three okayso twenty three lie between twenty two and thirty twoso we are going to take this link outso we took this link outtwenty three is less then twenty fiveso we come down here okayso twenty three in an node we will try to keep this key in a inserted orderso we keep them in a sorted order right yabecause only then ( ) twenty three should come in this place what should Ido move twenty four to the right and twenty three will come at this placeyaso insertion always actually happens at the very last node at the leafnodesso here other way could think of it twenty four was here I compare twentythree at the right to go left that's null pointerso that's mean I have to insert that node itselfokay so now we are trying to insert fortythere should be no problem with forty forty is more then thirty two so I goright I come here forty is more then thirty fiveso again go right (Refer slide time 23:48) and there is space here so Icompare forty with thirty nine is a null pointer so which is means I haveto put it right here there is space I put it okay[pic]so now lets say I was so  now if I am trying to insert a node (Refer slidetime 23:58)[pic]so now the question if I am trying to insert a node and there is no spaceavailable I am trying to insert a key and there is no space available andthen node in which the key should go then what do I do and that's anexampleso when I am inserting twenty nine that the kind of thing that could happenrightso twenty nine between twenty two and thirty twoso I follow this (Refer slide time 24:20)twenty nine more then twenty fiveso its wants to come and sit here between twenty eight and thirty exceptthere is no space here[pic]so this is what we are going to do we are going to split the nodewhich node have been going to split this nodethe one containing twenty six twenty eight twenty nine and thirtywe are going to split it in to the two okaylets say these are four keys the two smaller one will go to the(Refer slidetime 24:53) left and two larger one will go to the right okay and we willremove this node ( ) we need tolink up this node right this should be children of this guy here yes[pic]because this are all originally children of this node rightso this should also be child of this nodebut now its going to have three children but how many keys are there one sowe need one more key if it has three children it should have two key sowhich key I should put here okayI am going to have promote [noise:hindi]so its best to just promote twenty eight okayso that's what I will promote twenty eight here (Refer slide time 25:54 )[pic]I could also have promote twenty nineyou understand why twenty eight and why not twenty six if I promoted uptwenty six what could be the problem then the search property would not bethe valid yesso I have to promote either the largest key from this node up here orsmallest from here everyone with me rightso this will become the new structureso we have promoted one key to the parent and inserted that keywe could insert the key in to the parent because there was a space in 
# 24trees-5
 parent it might happen that you know when I am trying to insert the keyin to the parent the parent doesn't have any space [noise:hindi]seven less then thirteen so we have go to leftseven between three and eightso we should follow the second child we follow the second pointerso it should come here and we want to put it here except that there is nospaceso we will split this node two nodes created (Refer slide time 27:20)fourfive go to the left node six seven to the right node we have get read ofthis node these are the five children[pic]of this node now [noise:hindi]so if parent node does not have sufficient split then it is split okay(Refer slide time 27:35)[pic]so we split in the parent node in to twothree and five will go to the smaller oneEight ten will go to the larger one to the right to the other node okaynow I have one two three four five children right and they have to be madechildren of these guys okay and one of the smaller [noise:hindi] that hasto be promoted upbecause when a split happens then we take the key of the largest key of thesmaller node and promoted upso we are going to create so the left two would go in to these two leftchildren the first two children would be made children of this node theright three would be made in to this noderight two of this and three of thisbecause five is going to be promoted up rightso that means that only one key is going to be left here which means thatthis can have only two children the first two children will go here five isgoing to be promoted up so this will have two keys which means threechildrenso these three would be its children and we promote five up rightso we split this node [noise:hindi] that we split first then we went andsplit the parent and now we will see the split here also because this willnot have any spaceso we split in to two five thirteen will go to in one node twenty two andthirty two will go to the other nodethis will disappear(Refer slide time 29:40) [noise] and now one two threefour five these are five children so thirteen will get promoted up nowremember right[pic]so the first two will become children of this and the next three willbecome children of this and thirteen gets promoted but where does it getpromoted it is nothing at above right so we will create a new root (Referslide time 30:05)eventually we may have to create a new root its what goingto have we create a new root thirteen goes up there and these two becomethe children of this right[pic]so if we create the new root the height of the tree increases by oneis everyone with meyou understand the procedure rightso you try to so first you will come down the tree till you hit the leafyou will try to put the key there if there is space great nothing to bedonevery simpleif there is no space when you split that node ya and then we decided thatthe lower two lower keys will go to the one node and two higher keys willgo to the other nodethe largest key in the lower part would be promoted up rightso when we split there are four keys in a node there are four keys four[noise:hindi]to which mans the second key of those four ya is one which will getpromoted up promoted up means we are trying to insert the key in to theparent nodeif there are successful if there is a space no problem otherwise repeat thesplit process of the parent nodeso split it right and these split my cascading all the way up to the rootif its case up to the root and the root also get split then we have tocreate the new root that's it yaany questions greathow much time does insertion take so search was very clear search we takeorder login time (Refer slide time 32:33)[pic]how many splits can be there in process of insertion rightit's a each level we might be doing the splithow much time does one split take how much time does it take me for thesplit the node I will create two some two node [noise:hindi] constant timeindependent of the number yaso each node split takes constant timeso that total time order login [noise:hindi] greatso now lets look at deletion (Refer slide time 33:45)right[pic]so suppose I wanted to delete twenty oneso first as in the case of the binary search treefirst you have to search for twenty one find out where the key isin the case of binary search tree we recall deletion require threedifferent cases if the key was at the leaf then we just ( ) of 
# 24trees-6
 leafnothing to be doneif it was at the internal node then you had to then distinguish between onechild and two child the one child cases not really happening here rightso only two child cases we have to be worried about right if it is such asinternal node two children then what it we do we found the successor orpredecessor of the key lets say with form the predecessor and we move thepredecessor to that and delete the predecessor that's what we would mean( ) rightso we are going to do something similar herelets seesuppose I want should delete twenty one so twenty one there is no problemtwenty one is an node right so we will search for twenty one so we comedown here go right go left go right and I find twenty one right here (Referslide time 33:45)now why is the problem deleting twenty one its in a leaf node I can justremove it and I can remove it without violating the property of the twofour treein a two four tree we require each node has at least one key and at mostthree keys so after deleting this will still continue to have one key so noproblem okayso that's what is going to happen sorry so I am not shown the process butthis twenty one will get deleted we just mark it up nothing to be donenow if key to be deleted is an internal node (Refer slide time 37:35)is itan internal node[pic]fine for instance suppose I will try to delete twenty five rightso I search for twenty five I fine twenty five  bite here yaso what do I doI am going to swap it with its predecessor so what is the predecessor oftwenty five how do I find the predecessor of twenty five i am nowin the case of two four tree I will go left and then keep going right[noise:hindi] then I find the largest key in this node yaI find the largest key its twenty four so predecessor of twenty five has tobe twenty four I am going to swap this two okay then I am going to removethe twenty five from herethis is a same thing now I can remove the twenty five from here why becauseits leaf node already yes and there are more then one more then there aretwo keys in the leafso if I remove one there is no problemnote that predecessor will always be in the leaf in this case not in thecase of a binary search tree lets check this point outin the case of the binary search tree the predecessor of a node need not bea leaf noderightsuppose this was my binary search tree this was a node then I am findingthe predecessor so I go left and then I go right rightthis could have been in the binary search treeso what would be the predicessor of ten it could be this line rightyes this is not a leaf nodebut here predecessor will always be a leaf nodewhywhy would be the predecessor always be so how do I find the predecessor Igo left and then keep going right keep taking the right most childso when will I stop [noise:student]whatwhen there is no right childwhen there is no right child what does it mean [noise] right when my rightchild is null then that means that all the children are null rightbecause I cannot have a situation in which there is a node which has a keyit has no right child but it has left childthis is not a permitted at all here rightif there is a key then we have a both we will have two childrenif there were two keys then we will have three children and so on it greatso my predecessor would also in be a leaf so I would just remove that leafnode and I would be done so that's what I donow I have to recall I was deleting twenty fiveso I swapped twenty four and twenty five and now I have just get read oftwenty fiveso I get read of oh sorry I just have to get read of twenty fiveso I will get read of twenty five by that right twenty five is a disappearfromso very simple case as you can imagine problem raising when I am in a leafI am trying to delete a key from a leaf which was only that one key in itthat leaf becomes empty what do I do now (refer slide time 38:19) rightso lets look at there (Refer slide time 38:23)[pic]so if after deleting a key and node becomes empty then we borrow a key fromits siblinglets see what that meansso suppose I am trying to delete twentyso I search for twenty I come down in this manner rightI reach herenow if 
# 24trees-7
 delete twenty so twenty is removed problem is this is in a emptynode not permittedwhat will I doborrow from siblingwhat is borrow from sibling herewell this guys means only one sibling thisso can I borrow fifteen from here to here no it is ( ) 38:57 rightbecause search property is not going to be validso we are going to do something like a rotation like with in a AVL treewhat is it mean fifteen goes up and eighteen comes down fifteen goes upeighteen comes downnow everything is fine ya okayso then the next thing you are wondering is if I cant borrow from mysibling ya if I cant when can I not borrow from my siblingwhen the sibling has only one key in it right for instance now if I tryingto delete eighteen then that could be a problemwait lets see(Refer slide time 39:40) so if sibling has only one key thenwe merge with the sibling we merge with the sibling we combine with thesibling okay[pic]suppose I was trying to delete twenty three right so again so twenty threeis right here if I deleted this is an empty nodeso if try to borrow from a sibling right okaynow there is small catch here [noise:hindi]one and two right but I cannot borrow from this oneyou see whybecause for the search property it will get because you know if I have topromote something then twenty eight is going to come down but this going tojumble thisso when I say borrow from a sibling I really mean and adjusting siblingif I am I can borrow from here so when I am here I can borrow from here ifI am here I can borrow from hereif I am here I can borrow from here or from here rightbut here I can only borrow from this guyeveryone understand why this is requireso I try to borrow from here but if I borrow from here that is twenty sixgoes up and twenty four come down this is going to become empty yaso that's not going to solve our problemso what we are going to do is mergethese two are going to merge combine but if these two combine then thenumber of children here of this guy will become two which means[noise:hindi]so the key in the parent node which separate this two sibling which is thiskey which is separating these two siblings is going to move down in to themerge okaylets see I create a new node which is merge of this two nodes this goesmoves down and this also is these are all the only keys in the new noderightbecause there was one here there was none here and there was non here twokeys and all so they come and sittingthese two will now disappear and this becomes the child of this node right(noise:hindi) oknow what can happenso essentially what we have done is we said we are going to one of the keysfrom the parent node is going to come downbut  what if diverse only one key in the parent node right same as beforeright [noise:hindi] and so on and onso moving the key down from the parent node (Refer slide time43:02)corresponds to deletion in the parent[pic]deleting the key from the parent nodethis procedure will be same as that we have done in so far in this leafnodebut it can lead to the cascading right cascading as in right[noise:hindi]we will see that happening in this example [noise:hindi]this is the only child left of it parent right [noise:hindi] per sibling isalso only one keyso we are going to merge with the siblingwe are going to create a new node which is going to get the sibling key andthe key from the parent which is twenty twoso this is the situation nowright and we will delete this and this [noise:hindi] rightso because of this deletion height can reduce by one after all we saidheight [noise:hindi] right login base is less then what it was that meansheight has shrink what could happen ya or insertion may heightso everyone understand this procedure rightthere are just very few concept that we really and it insertion may split[noise:hindi] or deletion may [noise:hindi] right[noise:student] [noise:hindi] no point is doing thatso first you try to copy try to borrow if not successful then you mergegreatso lets conclude today's discussion (Refer slide time 48:15) height of atwo four tree we seen is login right[pic]this would actually be theta of login right because its at least login basefour and at most login base two rightso as far as deletion was concern we have not looked at vaning time fordeletion yet but you can see that that is also login why it was come downthe tree to search for the key that's login right and then we keep movingback upat every step 
# 24trees-8
 might up we might go to all the way back up to the rootrightso another login step each step where either borrowing one from the onefrom the sibling or we are merging with siblingbut all of them are constant time operation rightborrowing could corresponds to [noise:hindi] constant time right[noise:hindi]so what you seen in search insertion deletion(Refer slide time 48:15) alltake order login time in a two four treeso why did we come up with the very complicated data structurewhy are we doing all of this okayso well they are fine right no [noise:student] okayyou don't  ( ) this is the another reason we are going to see another datastructure called red black tree okay and that's also very fast datastructure for implementing dictionaries and what we are going to see isthat what we learnt about two four trees today's is going to be veryhelpful in understanding how the red black trees functionsso we are going to look at this  in next classso that we done in that today's discussion on two four trees 
# dfsgrapfs-0
                                 Lecture # 28                             Applications of DFSso today we are going to be talking about applications of depth firstsearch in the last class we looked at the depth first search procedurewe will also be discussing the running time of depth first search today andthen looking at an application of depth first search to checking if a givengraph is two edge connected yeah okayso recall what we did in the last class we we wrote a small piece of codedepth first search vcan some one tell me what this was [student: visited v equal to ]so the first thing we do is we said visited v equals one lets say and then[student: noise] okay I will not worry about the counters for now becausethat's [student: um all children ] for all [student: belonging to childrenof  ] for all w [student: adjacent] adjacent to vhe was saying children of v there is no notion of children of a node in agraph yeah for all w adjacent to vif visited  [student: of not of w ] if not of visited w then DFS v[student: w ] w that 's it yeah that's what we said earlier um DFSprocedure isit first marks the node as um then it will start the DFS on each of theadjacent nodes provided they have not already been visitedthat's what DFS v corresponds to okay how much time does this proceduretake it is a recursive procedure so you have to do something careful somecareful analysis of the running timehow much time does it take [student: number of number of ] why [student:because every um if statement ] pardon [student: every um ] compared whatdo you mean by compare [student: like we have to check the the end isvisited or not ]for every edge we have to go we will have to look at the edge twice okayyeah the answer is rightyou are basically doing a total time of order m actually I can just sayorder m because I am assuming that the graph is connected yeahin a connected graph m is at least as large as n minus one so you canalways say order mso lets just say order m and we have assumed graph is connected okay nowlets try and see what's happening here right and for this I am going to usemy adjacency list representation because that will also give you a betterpicture of what this isso recall that in the adjacency list representation of the graph there willbe one entry corresponding to node v this would be the adjacency list of vthe nodes which are adjacent to v yeah if a node x is adjacent to v then vis also adjacent to x because it is an undirected graphso x [hindi] when I do this step for all w adjacent to v what does this sayhow will I actually translate it into codethis is pseudo code right you don't really have a statement like for all wadjacent to v you what will you do you will write pardon you will yeah youwill basically have to traverse this [student: noise] this list right forthat you will have one pointer which points to the first node and then whenyou have visited when you have looked at this node then you will update thepointer to point to the next and so and on alltill the pointer becomes null right or reference becomes null then youwould have reached the end of the list that's what you will that's how youwill be actually implementing it rightso basically every time I go through this loop I advance that reference Iadvance that pointer by one yeah okaynow if this was the very first node u and it was not visited then whatwould I do I would start a DFS on u yeahas I consequence I will do some 
# dfsgrapfs-1
 computation and when that computationfinishes I come back to this DFS procedurethe DFS that I was doing on v and I retrieve that pointer essentially the Iwould have the the pointer is still pointing herethat because that was a local variable so to say you follow what I amsaying I would not start so suppose okaylet me say I advance through this pointer this was the longer list and Ireached this pointer reached at this pointlets say this node is A okay and A was not visited so I went and did DFS ofA when I came back from DFS of A then what is the next node I will see inthis for loopI will go beyond this beyond A I would not continue I will not start allthe way from beginning and how I am retrieving the fact that I was herelast pointer was pointing to this informationthis this is coming from the recursion the fact that in a recursion I makea recursive call I store the local variables [hindi] okayif I were not to write for all w adjacent to v I would have writtensomething like the following I would have lets saylets call the this array A I would have p equals A of V right what is P Pis this pointer of vso p initially is pointing to here right and I would be replacing this bywhile p not equal to null goodsomething like this this might not be completely correct but it will besomething like that while P not equal to null what would I do [student:noise]I will do something like that and this I will do P equals p equals p dotnext yeah you understand what this isbasically each one of them has a next and this w will p p dot data or p dotnode or some such thing rightwhat is w because we don't have notion of w right so it will be p dot datalets say right basically I am saying each one of these nodes has twomembers one is data and one is next right and P is (8.45) into this[Refer Slide: 8.45]                                    [pic]why am I going to all of this right if I if I have to replace this line Iwould have to do something like this this is how you will actually code itup yeah and this while loop this break braces ends hereso the while loop will now have these two statements in it why am I doingthis because now when I makeso now note that visited is not local variable visited is some global arraythe only local variable that I have here now is my Owhen I make this recursive call this P is stored on the stack so that whenI return from this recursive call when I finished DFS of AI was so lets now say P was pointing to here I am doing DFS of A when Ireturn from hereI will get retrieve this P back and I will increment p or um advance p likethis P would now point to the next oneI would come back to this P I would not come back to this P you know rightat the beginning or some such thing why am I saying thisthis is crucial for the running time of the procedure you can understandwhy because if every time I was going to start from the beginning then Icant say order m I am now using a same fact I will be traversing this listonly once for each node right [hindi]once I start traversing the adjacency list of a node I don't repeat anyentry in it I kind of just keep moving forward in that adjacency list yeahso what does that mean for each node I am effectively spending timeproportional to the degree of that nodesome of that degrees of that node is the number of edges two times thenumber of edges in the graph and so the total time required is order m yesshe said 
# dfsgrapfs-2
 edge is visited twice that's also true v x x v the edge v xis being looked at herewhen I look at this node because x is now treated as a adjacent node of vand the same edge xv x is looked at herewhen I look at this node x because v is being treated as an adjacent nodeof v right so actually every edge is looked twice exactly twice yeahand this gives you the running time is this clear we are heavily using thefact that this is a recursive program and when this recursive call finisheswe retrieve this particular local variable this local variable gets backthe same value it had before this recursive call was made rightnow if I told you that implement DFS without using recursion you will haveto use a stackyou will essentially simulate the recursion by using the stack but now itshould be clear what variables you store on the stackwhat information would you store on your stack [student: current pointer ]basically P the value of Pso in the case of recursion two things are stored actually not just P somesomeone else has to tell me what else is stored [student: v also]v local variable [hindi] they are stored and the parameters to thatprocedure are also storedso the parameters to this procedure is v that will also have to be storedin the stack of course the stack also storesyou know return address and stuff like that but those things you don't needhere because you know exactly where it is returning to yeahso this will be your sixth assignment okay you will have to implement itI will give out the details later but you will have to implement DFSwithout using recursion[Refer Slide: 13.16]                                    [pic]so that you understand this way great so we looked at DFS we haveclassified the edges has tree edges and back edges okay and we have lookedat what the running time of DFS is one other thing that perhaps we shoulddo before we proceed further is look at this distinguistion between treeedges and back edges once more right so tree edges and back edges rightsuppose I have an edge u v which is a tree edge and if u v were back edgelets see what what can we say about the relation between the arrivals timeand the departure times for the nodes u and v okaylets see let me ask you these questions suppose I tell you that the arrivaltime of u was less than the arrival time of v yeahthat is I reached node u before I reached node v [student: back edge ]pardon [student:  u v form a back edge ] u v form a back edge rightsuppose I told you I gave you this information I reached u before I reachedv now what is the relation between the departure times of u and v [student: um departure of v is less than is less than the departure of um ]departure of v is greater than or less than [student: less than um lessthan ] departure of u is less than or departure of v is less than [student:departure of um v is less than ] [hindi] you reached u first u v is a backedgeyou reached u first and then you reach v what does that mean v is adissonant of u in the tree yeah [hindi] u v is a back edgeso there has to be an ancestor dissonant relationship between the nodes ofu v one has to be an ancestor of the other which is an ancestor of which[student: noise] clearly you will reach an ancestor before you reach thedissonant because you are coming down from the top of the treeso u is a ancestor of v in fact I have shown that in the pictureessentially right so u is an ancestor of vif u is an ancestor of v n this tree then first I would have finished v andonly then I would have backtracked all the way 
# dfsgrapfs-3
 come back to u andfinished u [student: same um ] no this is for the back edge right okaythis is not a tree path sorry so there is some tree path between u and valso of course and lets say this is the edge u vthere are other nodes on this tree path so you would have finished adissonant before you move up right because that's how you backtrackyou finished a node and then only then you move back up and then you finishthat and you back and back and so onso the departure time of u is more than the departure time of v you wouldhave left v we would have finished v before we finished you okaywhat if u v is a tree edge would that make the difference suppose one againthat arrival of u is before arrival of vif arrival of u is before arrival of v than u is a parent of v so u v u vhave a parent child relationship not just an ancestor dissonant but anparent childu is a parent of v right [student: why um ] because it is a tree edgeu v is a tree edge right so when I depart from v after that only will Idepart from u so departure time of v is less than the departure time of unote I cannot say that the departure time of u is one more than thedeparture time of v [student: because um] because it might have morechildrensimilarly I cannot say that the arrival time of v is one more than thearrival time of u because it there could be other children also yeah[Refer Slide: 18.05]                                    [pic]so the relationship is the same but right these are the same relationshipbut they coming from different reasons roughly the same reason okay agreedgranted okaynow lets look at an application of depth first search to to determining ifa graph is two edge connectedso let me write down connected right so that's the term that I am going tobe using G graph G is two edge connected if and only if G minus e isconnected for all e [hindi] I am saying take any edge capital E is the set of edges when I write graphas v comma E v is the set of vertices and capital E is the set of edgeslittle e is an edge G minus e [hindi] remove the edge from the graph if itis still connected and this is true for every edge for the graphthen we say that the graph is two edge connected rightin words a graph is two edge connected if it remains connected even afterthe removal of any edge [student: noise] yes only one edgea graph so a graph is two edge connected if and only if it remainsconnected after the removal of any one-edge okayso lets see is this graph two edge connected if I remove this edge then itbecomes disconnected such an edge whose removal disconnects the graph isalso called a bridgethis edge we would call it a sorry bridge oaky this graph is not two edgeconnected is this graph two edge connected [student: yes yes ] yesso graph which is two edge connected will not have any bridge edge a graphwhich is not two edge connected will have a bridge edge okaywhy do you think this notion of two edge connectivity would be useful[student: noise] rightso if this were a computer network and some link fails right then you areinterested in whether the network is still connected or notif your network was two edge connected to begin with then no matter whichlinks fails your network can still keep functioning because it will stillremain connected but if the network were not two edge connected to beginwith then the failure of a link can call the network to become to breakdown into disconnected componentsso that you know messages cannot go from one side of one connectedcomponent to the other anymore yeah[Refer Slide: 21.55]     
# dfsgrapfs-4
                               [pic]so this is basically measuring liability of the network so now the questionis a following I give you a graph and I ask you is it two edge connectedhow will you check if it is two edge connected right anyone [student:  umif we can suppose we have from one end point to the other point of an edgeum sir each vertex um ] for each vertex if we can find a cycle how how youcheck given graph is two edge connected we have to do it fast pardon[student:  we will look at the departure time ] if you look at departuretimes [student: sir between any two node there should be a tree edge alsoand back edge also ]between any two nodes there should be a tree edge and a back edge [student:noise] [hindi] [student:  um so on removal of either of one its stillremain connected] [hindi]each node should be visited twice [student: um between any two node] okaylets don't don't worry two much  about DFS because that is not straightforward but you will see how to do it yeahlets see can you check this property of two edge connectivity by by someother mechanism [student: sir by BFS noise ] yeah BFS yes what will you dowith BFS [student: noise] so you have to check if the graph remainsconnected even after removal of an edge right so take an edge remove itcheck if it is connected then take another edge remove it check if it isconnectedtake another edge remove it check if it is connected [hindi]so that's more expensive right we can do it in order m square by removingevery edge and checking if resulting graph is connected yeah yesbut that's expensive for us so we want to do something in order m timelinear time [student: um say that v vertex has a back edge] if every vertexhas a back edge then only then is the graph two edge connected [hindi]is a cycle two edge connected graph it is two edge connected right [hindi]what will be the tree edges [hindi] rightso this will be my DFS tree the one in red and the only back edge will bethis last edge[Refer Slide: 27.05]                                    [pic]so my DFS tree if I were to draw it differently would look like this itwould be a path my DFS tree with one back edge only okay [hindi][student: um when you are back tracking from that vertex if you get a backedge that means there is a cycle connected that particular path oftraversal so you can then compute something ] good we are getting somewhereso lets develop this one step at a time so I did a depth first search soclearly we have to do a depth first search rightsuppose this is the depth first search tree I obtain right I have justdrawn tree edges there are other back edges I am not drawn them yetnow when I am backtracking out of this node backtracking means I am goingback up and because I have explored this entire thing what do I require Ihave explored this entire thing I have not yet gone here so I have comefrom here I came like this I came like this I explored this entire thingnow I am back tacking right I want to ensure that this edge along which Iam backtracking is not a bridgeI want to ensure that it is not a bridge [hindi] what will ensure that thisedge I am only interested in this one edge not being a bridgewhat we ensure that this one edge is not bridge [student: um it isconnected it is also back edge um]there is a back edge from  where [student: from this vertex] from thisvertex [student: yes yes ] from this vertex [hindi] [student: noise]any of these vertices say [hindi]if 
# dfsgrapfs-5
 remove this edge right lets look at the blue tree the DFS tree in atree when I remove one edge I will get two pieces not more yeahthis will be one piece and the other remaining piece I cannot create morethan two pieces by removing an edgeI create exactly two in a tree now this two pieces are connected amongthemselves by the tree edges that the blue edges rightso I can from any node to any other node how will I go from a node in thispiece to the other piece by going from that node to the end point of thisgreen edge taking this green edge going there and then going from here towhichever node I wanted to go toso which means every pair of node is connected which means that the entirething is connected even after I have removed this red edgeso this red edge is not a bridge so if such an edge is present then thisedge is not a bridge [hindi]but it has to go this node or beyond [hindi] I will get two pieces whichare disconnected from each other because there will be no edge going fromhere to anyone here because we said there is no edge of this kind right[hindi]so this is the condition we have to check everyone understandsso what is the condition we have to check when I backtrack from a node whenI backtrack from a nodeI have to check that there is some edge from here which is going to anancestor of this node [hindi]how will I check this linear time [hindi] [student: um] [hindi] thereshould be some edge from its descendent to its to one of its ancestors that's allso let me write it down in words so when backtracking from a node v we needto ensure that there is a back edge from some descendent of v to someancestor of v [hindi]so I have said descendent without saying proper descendent so descendentincludes the node itself but this ancestor is a proper ancestor which meansparent or above [hindi]now we have to somehow ensure this how will we check this property and wehave to it all fast[Refer Slide: 35.47]                                    [pic][hindi] we are only permitted order m time [student: do we keep track ofthe back edges then we back track on particular node we believe from ourrecord that particular back edge um that node um ] um keep track of allback edgesdo we need to keep track of all back edges [student: which um ] right[hindi]I am interested in a back edge rightbut do I need to keep track of all the back edges starting from [student:noise] which is the back edge which is of interest [hindi] if if we keeptrack of every back edge then we are going to be spending a lot of time[student: sir we will delete the ] but there is one back edge which is ofinterest to uswhich is the one back edge which is of interest to us [student: noise][hindi] clearly if I know [hindi]you understand what I mean by [hindi] is going to the node which is closestto the root how can I figure out which is the deepest back edge by lookingat the arrival time of the other end point [hindi]so just by looking at arrival time [noise] of this end point I can figureout what the [hindi] now question is how am I going to built thisinformation recursively rightI have to find out the deepest back edge from this sub treeso I just keeping track of the deepest back edge   now I have to find outthe deepest back edge from this sub treehow will I find out the deepest back edge from this sub tree supposerecursively I have done this informationI have figured this information from the sub tree I know the deepest backedge because after all we are doing recursively rightwhen I run the DFS from here when I run the DFS from here I actually end uprunning DFS's fromlets say 
# dfsgrapfs-6
 three yeah so suppose  figured out the deepest back edge fromthis sub tree I figured out the deepest back edge from this sub tree and Ifigured out the deepest back edge from this sub treehow can I compute the deepest back edge from this sub tree [student:compute that compare um] compare all three [student : and then um ] andtake the minimum[student : and from u also ] the one with the minimum arrival time [student: um corresponding with the minimum arrival time ] rightso this will give me an edge whose other end point has a smallest possiblearrival timethis will give me an edge whose other point has a smallest possible arrivaltime this will give me a edge whose other end point has the smallestarrival timenow if I take the minimum of these threeit will give me the edge which has the smallest possible arrival time whicheminates from this sub tree is this true [student: noise] [hindi] okaygreat rightnow lets write our DFS procedure right so this is our lets give it someother name to distinguish it from DFSlets call it two EC two edge connectivity right so we are writing a twoedge connectivity procedureonce again it will take as input a particular node when we will okay we aregoing to write it has the DFS thing and I will tell you how we have to callthe DFSthis two edge connectivity procedure eventually okay recall I need thearrival times of the nodesso I should maintain my arrival counter suitably right so what should I dofrom my arrival counter [student: um time is equal to zero] [hindi] for allw adjacent to v same thing for all w adjacent to v do what should I do[hindi]  arrival value of this node itself would be a natural thing to dorightlets set that at that okay now deepest back edge [hindi] as I do my DFScall I have to kind of keep updating this variable yeahso what should I do for all w adjacent to v do if not visited if notvisited w then then what should I do [student: then if then arrival v orsmaller than dbe ] arrival v [student: sir your DFS um ] then [student: DFSof W ] dbe equal minimum of dbe comma [student: comma DFS DFS w um] DFS w[hindi]of sorry two EC yeah two EC of w [hindi][student: sir even it is even it is visited ] if the node is visited thenwhat does that mean what edge is it [student: um back edge] it is a backedge [hindi] rightso else what should I write on here [student: if you are maintaining that dec w and some particular array then you can write that minimum of I willsay I have to write the same thing again minimum] we will just write thesame thing dbe equals minimum of dbe comma [student: two ec w arrival of ]not two ec we are not running a [noise] arrival of w yeah [hindi]now what do I have to check [student: if it is less than or um ] if if db[student: arrival of v ] if dbe is less than [student:  arrival v ] arrivalv [student: never be possible um ] um [hindi]if dbe is less than arrival v [student: that is um] then then okay thencontinue [student: there we can um then we can continue] then we cancontinueif dbe equals arrival v [student: um] then [hindi] then abort basicallythey basically then you stop your procedure sayingyou found a bridge right you can do whatever you want I will just writeabort here you should not write abort right you should end gracefully butyou understand what I am saying basically why have we said equal to and notgreater than greater than or equal to greater [hindi][student: sir can you explain else part if w is um] he wants me to explainthe else part why do we need the else part you are wondering[student: we need the else part] you need the else part okay great[student: but why arr w what is the significance of arr w um] what arrarrival w well there is this corresponds to the else corresponds to a backedge starting from 
# dfsgrapfs-7
 is going to a node w yeah w is a node which is adjacent to v so it isgoing to a node w andhow am I keeping track of deepest I am keeping track of deepest by arrivalnumbers of the nodesso that's why I am comparing it the arrival of that node with this [hindi]so I need that and if the deepest is less than this v then its okay I cancontinue if it is here only deepest is this then this means this edge is abridge [hindi]no we cannot say anything about the arrival time of this verses the arrivaltime of thisI have said this before we cannot say that this is one less than that sobasically we have to modify this so that I am not considering this edgethis tree edge rightso this has to be modified so that the tree edge is not considered thisparent edge is not considered [hindi]when we do the DFS from that vertex we visit all the vertices all the backedges any if any coming from below cannot go to some um smaller numberclearly they are only going up to this vertex rightbecause this vertex has the arrival number zero there is now vertex witharrival number less than zero[student: dbe should not be zero um] [hindi] basically [hindi] right thereare many ways of doing ityou could perhaps have mark this tree edge right you will have to think ofways of doing thisI will leave that as an exercise yeah so these are two minor things butthey are importantyou procedure would not run at all if you were to ignore them yeah okaywhat is a running time [student: noise] [hindi]so essentially as same as before for every edge we are spending a constantamount of time rightso the total running time is still order m this is clear right so actuallyvery sophisticated procedure can be built on top of DFS right[Refer Slide: 52.46]                                    [pic]there are many other graph problems which can be solved in liner time theymight seem very complicated problem but you can essentially solve them inlinear time using depth first search rightso there is I will mention one other problem because I have a couple ofminutes we will not of course discuss itso the other problem is is G a planar graph do you know what a planar graphis you are not done a discrete math's paper no you are doing it nextsemester right [hindi] that is not sufficient rightwhat is a planar graph a planar graph is a graph which can be drawn in theplane such that its edge is do not intersect [hindi]this is a planar graph [hindi] I can draw it whichever way I want but theedges should not intersectnow suppose this is what is this graph this graph is the complete graph oralmost the complete graph on five verticesI told you what the definition of a complete graph is right complete graphfor a cleak (54.55) complete is this the complete graph compete graph onfive vertices no why not [student: um] the edge two five is missing twofive is missing [hindi] two five which is the edge which is missing [hindi]there is no way I can draw two five here without crossing and that isnothing to with the way I drew the initial thing [hindi]there is no way I can draw two five so actually this complete graph on fivevertices is not a planar graph [hindi]if I were do draw it this way it would cross with this if I were draw itlike this it would still crosses with this edgeif I were to draw it like this it would cross with this edge and so on andon so there is no over drawing this okayso that's the question is a given graph a planar graph this problem can besolved using depth first search[Refer Slide: 56.07]                          
# dfsgrapfs-8
          [pic]so that you can get an algorithm which runs in linear time order m timevery sophisticated algorithm rightto check if the graph is planar or not so this is an example of a nonplanar graph that I had shown rightyou learn about this in you discrete math's course what what are non planargraphs what can you say about non planar graphs [hindi]so this is another example of depth first search but we are not going totaking up in this up in this coursethere is one third example which I will do in two minutes so just I definedtwo edge connectivity I can define two vertex connectivityjust replace the edge by you vertexa graph is two vertex connected if if removing any vertex still keeps thegraph connectedthis corresponds to computer failures now instead of link failures earlier[hindi] then you would call it a two vertex connectedso no matter which computer breaks down if the network is still functioningit is still connectedthen you would call it a two vertex connected graph yeah for instance thiswould be a example of graphis this two vertex connected no why because if I remove this vertex itbecomes disconnectedwhen I remove a vertex I also remove edges incident to that vertex clearlyit becomes disconnected but this is two edge connected graphthis graph is two edge connected yeahso once again the same question given a graph is it two vertex connectedthat can be checked by depth first search in linear time again such avertex is called a cut vertex right bridge [hindi] corresponding notion iscut vertex here okay[Refer Slide: 58.31]                                    [pic]so these are so we have done in today's class we have done example of depthfirst search which is checking if a given graph is two edge connectedthere are many other application that depth first search can be put to Ishown you I mention briefly two exampleschecking if a given graph is a planar graph and checking if a given graphis two vertex connectedso next class we are going to look at depth first search in directed graphsright and see how is going to be different from undirected graphs 
# binheap-0
 Lecture # 27                          Depth First Search (DFS)today we are going to be talking about depth first search this is anotherway of searching a graphso in the previous class we looked at breadth first search there arecertain application where depth first search is more meaningful thenbreadth first search and we are going to look at these application alsoyeahso one application is the following you are a mouse you all know who youare so you are a mouse[student: she is ] and there has to be whatever something carrot [noise] noi thought you said carrot oh it was cat okayso there is a piece of cheese at the end of the maze right and you have tofind you way to this cheese right[Refer Slide: 02.06]                                    [pic]so this can be thought of as a graph in the following sense right at eachof these squares i put down a vertexwe we come to that in a minute so what will a mouse do right the mouse isnot going to breadth first search right unlikely that is going to do it isnot even going to do a depth first search rightbut what it ends up doing is something like a depth first search okay sowhat this mouse is going to do as all of the mice would is thatit is going to go of in one direction yeah and try to explore that paththat direction fully and if it's not able to get to the cheese is going totry and backtrack yeahso we will understand what all of that meansso lets assume that our mouse has photogenic memory right it kind of knowswhen it comes back to the certain place it knows that it has been at thisplace and it knows what path it tookwhen it was in that place last time right we of course have data structuresto keep track this information yeahbut lets say mouse can also keep track of this so lets say it started fromhere and it went down one step and it did not find its cheeseso it came down another step not yet so lets say it decided to go right whyI don't know it just decided to go right yeahso it is said to go right okay and then it moved another step and at thispoint it can only go down so it went down yeah and again it came down hereand lets say whenever it has option it can always goes right yeahso it goes right again [student: sir left] [noise] [hindi] yeah okaylets say it [noise] so lets say that the mouse tries to take this directionfirst east and then it tries to take this direction south and west andnorth yeahso now there is no dought about left and right so it will try to go againeast and did not find the cheese so now it has to it cannot go eastso it goes south and south and now it is stuck right so it cannot goanywhere else because all the three sides are blocked but it can move itwhen it gets stuck like this it backtracksbacktracks means goes back to the place where it came from right so it goesback okay and at this point it knows it has been here beforeit went south so it now tries to go west but it cannot go west so it willit has no other possibility but to go back to where it came from and itcame from hereso it goes back right and similarly here it goes back and it goes back atthis point when it reaches it sees that it has another option which it hasnot explored rightwhich is going south so it goes south now yeah and then it comes here itcomes here now it will have no other option but to go west west north northnorth and now it comes to this point rightit comes to this point but its sees that this is the point which it hasbeen to before it is already been to this placeso it is not going it is not going to go and it is not going to go to thispoint any more if it has been at a particular cell before at a particularlocation beforeit will not go there again because otherwise it will just keep going in aloop right it will not make any progressso since it has been to this point before it will not go here at this pointit has no other option left it cannot go east it cannot 
# binheap-1
 west rightif it goes north it goes to a place where it has been before so itbacktracks backtracks so at all of these points it will have to backtrackbecause there is nothing to be doneand it comes back at this point at this point it had explored the twooptions it had right the third option is not an option it it cannot go westso it will backtrack backtrack backtrack come herenow here if it tries to go south it sees well this is a place I have beento before why should I go there it is after all just trying to find wherethe cheese isif it has been to a place before there is no point going there again rightbecause it will then repeat the same sequence of stepsso it doesn't go here right that's one important thing that the mouse doesand so it backtracks and backtrack and comes back to the starting positionwhat have we learned it is not so easy to find cheese right okay so now itwill take the other option comes here comes here comes here comes herecomes here comes herehe said it will first try to go south south struck backtrack backtrack atthis point it has another option goes there goes there goes there goesthere and now it is a homerun [noise] right time to clap no okayso it has found the cheese so this is what we will call depth first searchand we will formalize this shortlybut this is fairly natural way of exploring right it is not artificial itis you don't have to be a mouse to be doing this rightyou take a particular direction and you try to follow it till wherever itwill reach you it will till whatever you can you know using that directionso direction here now corresponds to in our graph sittings it willcorrespond to taking one edge going out along that edge rightto the next vertex and continuing and seeing where all you can reach rightokay and then if you cannot reach any other vertex then you startbacktracking rightso while there was a notion of goal here which was the cheese and you wouldstop here in our depth first searchthere is no goal really right so our depth first search would just be amechanism of exploring all the vertices of the graphwe will keep continuing our depth first search till we do not come back tothe starting vertex and there are no other options left from the startingvertex so to say right[Refer Slide: 7.58]                                    [pic]our search is basically a method of visiting all the vertices with thegraph okay so now let me do a depth first search on a graph and show youwhat you get and I will start including some terminology now so this is thegraph we are working with an undirected graph for now rightthe notion of a depth first search is applicable also for directed graphsso small simple graph and six vertices and I am starting from this vertexso as in the case of breadth first search there is always a notion of astarting vertex I am starting from this vertexand what am I going to do I am going to take one edge out of this vertexrightso in the case of the mouse we choose a particular ordering rightwe said first we will take the path the option going east then south thenwest then north righthere we can choose whichever we want and typically typically we are goingto take so recall we are working with the adjacency list implementationrightso for every node so recall and adjacency list implementation you have anarray and for each vertex you have a link list and this link list is a listof adjacent verticesso the first edge I will consider is the edge going to the first vertexright and when I have worked with this edge and I am explored everythingall all the places I can reach with this endand I come back to this vertex then the next vertex I will consider is thisone and so on and on rightso suppose here I was this was the first edge I considered I went alongthis edge to this vertex okay okayI am now going to just so that you follow the procedure I am going to do atime stamping what does it mean nothing muchI started time zero when I reach a new vertex I increment my time [hindi]so I will say I reach this vertex at time one so one two three will tellyou what is the sequence in which I visited the verticesso I reach this vertex at time one okay now I start from this from thisvertex 
# binheap-2
 am going to look at the label options I have yeahI have three different options let me say I first took this option and cometo this vertex [noise]so I came to this vertex at time two right at this vertex do I have anyother option well there is this edge going out but when I go along thisedge I see I come to a vertex which I have already been to vertex zero hereokayso there is nothing to be done at this vertex yeah there is nothing to bedone at this vertex so what do I do nowI backtrack I leave this vertex I am done with this vertex so when I amdone with the vertex I am again going to increment my timeso I came to this vertex at time two and I am say going to say I am donewith this vertex at time threeI will just increment our time counter this is not particularly useful thistime counter but there will be one application where we will use at this isjust right now to show you how things are progressingI done this with this vertex and then where do I go back backtrackbacktrack means go back to the vertex where we came fromso I come back to this vertex yeah and now can I backtrack out of thisvertex[student: noise] because there are no other adjacent vertices which I havenot exploredso lets say this is the next one I go to or leno um yeah okaylets say this is the next one I go to why not right so I take this one andI reach this vertex at time fourum no so so our numbering is you know when we reach a vertex we incrementthe counter and we backtrack from a vertex then we increment the counterthat's the only way we number right so I am not saying that I leave fromhere at time three I get to here at time four then I you know I could dothat alsobut why keep incrementing unnecessarilyso I am going to increment only one I reach a new vertex so I reached a newvertex I give it a time stamp of a four yeahand now at this vertex what are the other options I have I can go alongthis edge or I can go along this edgelets say I decided to go along this edge yeah so I decided to go along thisedge I came to this vertex at time five sayat this point I could go along this edge to this vertex but again thisvertex is already visited yeahso I am not going to do that I am since there is no other option left Iwill backtrack out of hereso I have finished my visit at this vertex a time six backtrack alwaysbacktrack to where we came from we came from four so we go back to thatso now I come back to four but there is one other option at four which Ihave not explored which is going like thisso I am going to follow that now and reach this vertex at time seven yeswhen I reach this vertex at time sevennow I look at the other options I have this is one option but this leads tome to a vertex which is already visitedthis is another option I have but this also leads me to a vertex which isalready visitedso no other options I have backtrack out of seven at time eight I backtrackout of seven and I come back to this vertex at this vertex I have exploredup all all optionsI went along this edge I went along this edge and had come along this edgeso so this is the only edge left in some sense so I go back along thisright I have explored this I have explored thisso I am ready to backtrack out of this vertex so I backtrack out of thisvertex at time nine backtrack out of this vertex at time nine and where doI end up at this vertex rightso now reach this vertex at this vertex I have explored this possibility Ihave explored this possibility I have not yet explored this possibility butthis is meaningless because this vertex is already visitedso I have explored all um possibilities out of this vertex so I nowbacktrack out of thisso I backtrack out of this at time ten and I come back to this vertex atthis vertex I have only explored this edge yetso now I go explore this edge but this is going to a vertex which isalready visited so I cannot do anything this is going to a vertex which isalready visitedso I cannot do anything this is going to a vertex which is already visitedI cannot do anything so I am done with this vertex also rightat time eleven I finish at this vertex rightso each vertex is 
# binheap-3
 given two numbers the time at which we came therethe time at which we left six vertices[Refer Slide: 16.49]                                    [pic]so there should be twelve numbers in all and that 's what we have zero toeleven right so this procedure is called a depth first search [noise] anyquestions so far okayso once again we will have a notion of black grey and white vertices rightjust we had in the case of breadth first searchso what should are initial color on the vertices be [student: white ] whiteunvisited same as breadth first searchwhen should I color a vertex grey [student: reach that node ] when I reachthat node then I color it greywhen should I color it black [student: noise]when I leave that node eventually then I should color it black is it clearto everyone right same as same as in the breadth first searchwhen I had removed the node from the queue when I inserted the node intothe queue in breadth first searchI color it grey when I removed it from the queue when I removed it from thequeue I put its neighbors into back into the queueif the um if any of the neighbors is white I put into the queue and I colorthis node blackso corresponding thing here would be when I leave a node when I backtrackfrom a node rightI have explored all possibilities going out of that node then I color thatnode black rightso at a node so if I am at a node I will look at its neighbors right andwhich neighbor will I go to so would Isuppose this is the first neighbor I consider wid I in what circumstanceswhat should be the color of this neighborso that I would go to this neighbor white right yet to be explored only ifthis node is white will I go to this nodeif it is black or grey then I will not go to this node at all yeahso I am at this node this is what I am saying if if this node is white onlythen do I explore it so to say okaylets understand this example a bit more lets mark out the edges along whichwe traveled in the course of our breadth first search with redso I travel along this edge because I came from here to here along thisedge right how did I reach twothis from this one so I traveled along this edge yeah so once I went alongthis edge then I backtracked along this edge then I went along this edgethen I went along this edge then I backtracked along this edge then then Iwent along this edge backtracked along this backtracked along thisbacktracked along this yeahso each one of these red edges I have um I have went along tem twiceonce i went along the edge the other time i backtrack along the edge righthow many such edges are there how many red edges are there [student: nminus one um]the number of these red edges would be n minus one why [student: um forwardtree] why it is a tree who said it is a tree[student: sir because we don't know um we have visited there is no noise]okaywe are going to use a different argument for its tree first why should thishave n minus one edges rightwhy should this have n minus one edges well for every edge for every vertexthere is one edge along which i came to that vertex and the the same edgealong which i backtrack from that vertexso for every vertex there is a unique edge except for the first vertex sosince for every vertex there is a unique edge except for one there shouldbe n minus one edges rightso number of red edges equals n minus one right if i just look at the rededges they form a connected sub graph why why do they form a connected subgraphwell because using by walking along the red edges I could visit all thevertices yes all I did was walk along the red edgesthat's all I did so by just by using the red edges I could visit all thevertices starting from the root from this start vertexso these red edges form a connected sub graph[Refer Slide: 23.00]                                    [pic]so connected sub graphs with n minus one edges is a tree yes we have donethis beforeif I have connected sub graph with only n minus one edges in it it cannothave a cycle we 
# binheap-4
 proved this rightso it's a tree so the red edges form a tree and this tree is also calledthe DFS tree the depth first search tree yeahthis is clear just as we had a breadth first search tree a breadth firstsearch was defined in terms of predecessorshere also we can have a notion of a predecessor what is the predecessor ofthis vertexthe vertex which was visited at time one because why why should that be thepredecessor well I came to here from thereso that is an actual notion of predecessor right and these edges then sothe same thing same idea is getting repeated rightjust has we had breadth first search tree there we have a depth firstsearch tree here but the breadth first search and the depth first searchtree are completely different yeah okaywhat I am going to do now is to redraw this tree so I am going to keep itlike this can you all see the picture greatand I am going to redraw it so that it looks like a rooted tree now so thisis this vertex and let me draw it in brownthis is that and the next vertex would be there and from here I have thisso this is this vertex that I have drawn from hereI have an edge to there and I have another edge right these are all the sixverticesif you want I will put down the numbers so that you can also see thecorrespondces well this is zero slash eleven this is the one slash ten thisis two slash three this is four slash nine five slash six seven slash eightright andlet me also draw the other edges of the graph right I right now I have onlydrawn the tree edgesthe DFS tree edges right these are the edges along which we traveled let mealso draw the other edgeshow many other edges do we have we have four other edges there is one edgefrom here to here there is one edge from one ten to seven eightthis is another edge right this is this edge there is one edge from seveneight to zero eleven this edgethere is this edge zero eleven to five six oops okayso let me let me draw it like that right this is an undirected graph sothese directions that I have shown are meaninglessit is just to signify that this is how we moved right and now I can get ridof this pictureso this is our graph I have just redrawn so that now it looks like a rootedtree right  and the predecessor of the node now is just the parent of thatnode rightif I define this as the root then there is a natural parent childrelationship between the nodes yeahthe parent of this node is this and it is also the predecessor right soquite often we will talk in terms of parent child siblings and all for aDFS treeso when we say that that basically means we are thinking of the startingvertex is the root of the tree and we basically hanging the tree from thereand then you know whatever is the parent child relationship that getsdefined that's what we are working with [noise] great [noise] okayso lets look at more properties of depth first search um these edges thesegreen edges so the brown edges are called tree edges right that's the brownedgesthe green edges are called back edges and we will see why they are calledback edges and why not front edges rightwhat's back about them okay so now let me think of depth first search hasbeen done on this graph this is the entire graph all the edges is and thevertices are here yeahI started from this vertex I came down to this I came down to this and thenI looked at this was one option I have label to me yeahbut this edge was going back to a vertex which I had already visited yesand so this is called a back edge going back to vertex which is alreadyvisited [hindi]so then it is going back to a vertex which was already visited so I don'tgo there there is no other option left hereso I backtrack right this is the option here I come here I come here againthis is an edge going back to a vertex which is already visitedso I don't go along this edge I backtrack from here I come here this is anedge going back to a vertex already visitedso I don't go along this I backtrack I backtrack right well I could nowlook at this edge again and say well this is going ahead to a vertexalready visitedso I could potentially have also called it a front edge but since we firstconsider it has a back edgewe ar going to stick to the term back edge yeah so this is an edge we goingto a 
# binheap-5
 already visitedso we don't consider this and since all option I exhausted here  back trackI come here these are all edges which we have so to say have beenclassified as back edgesso we don't or they are going to vertices which are already visitedso we don't do anything and we are done okay so who can formally define forme what a back edge iswhat is a property of a back edge okay now okay I think I am getting a headof myself now I have the following question could there be an edge fromthis vertex to this vertex could this dotted red edge be inso um drawn a dotted right most likely not be there yeah but why [student:noise] yeahwhen I came to two when I came to this vertex at time two then Ibacktracked out of this vertex because only because there was no otheroption available to mebut if this edge was there then this was a option available to me whybecause this vertex was not yet visitedthis vertex was visited only at time four so at time two this vertex wasnot visited and so it is still a white vertex and so I would have gonealong this edge and if I gone along this edge then this would not be thepicture at all rightso clearly this edge is not there in the graph [student: sir we have thelevel difference um] no we will we will understand what these edges are ina secondso it is not nothing to do with level here unfortunately yeah so this isagain two we are saying edges which jump a level in breadth first searchthey cannot be because if they were then that would have not been ourbreadth first search that would have not been this collection of levelsso if this edge was there then this would have not been the picture at allit would have been something completely differentso this edge is not there this edge is not there similarly this edge fromhere to here is not there or from here to here is not there yeahso what are these edges which are not there what can I say about edgeswhich are there and edges which are not there [student: noise]sibling but this and this are not sibling [student: um there is no ancestorwhich um]so what are the edges which can go from here which can emanate from herethey they are only edges which go up to to root or to ancestors [student:ancestors] okayso lets understand this this is an imp very important point right I havereached the certain vertex and this is lets say the sequence of verticesalong which I reached hereI am sitting at this vertex at this point right and I am ready to backtrackback ready to backtrack [hindi]there is no other option available to me so what are the other edges whichcould have stated from herethese are only two vertices which have already been visited yeah well theseare clear vertices which have already been visited rightso there could be edges from here to here but why can't there be an edgefrom here to um some other vertex which has not already visitedwhich has already been visited [student: there will be no need um insteadof vertex ]no so why did you say only ancestors so suppose this was my vertex hereright why are we saying that only two ancestorwhy can't have an edge from here to here [student: because then it would bea ancestor of this and have been visited earlier it would be um] rightif there was an edge from here to here [student: it has to be child of umancestor when do we backtrack before backtracking we would covered thatvertex that path would have already been covered ] right okay [noise]so what is a formal way of saying this why should why should we have onlyedges from a vertexso okay so the so lets just put down what we have concluded so far from avertex we can have edges only to ancestors right and such edges are calledback edgesso what is a back edge so now we are ready to define what a back edge isanyone what is a back edgean edge [student: from a node to another ] from a node to an ancestor whatis an ancestor what is an ancestoran ancestor with respect to the depth first search with respect to the DFStree right the notion of an ancestor is coming in only because we havedefined DFS treeso an edge from a node to an ancestor is called a back edge [student:noise]but not to [student: but not to parent] yeah an edge from a node to a parent is a tree edge yeah so we willdistinguish between tree and back edgesso an ancestor is not a parent lets see now okay so those are the backedges and these edges the once 
# binheap-6
 the red dotted here or not back edgesbecause they are not from a node to its ancestor neither is this node anancestor of this nor is this an ancestor of this rightso such edges cannot be there at all in our graph so depth first searchbasically means so if you do a after you do a depth first search you end updividing now the set of edges into two classes [student: tree edges] treeedges and back edgesand there is no other edge [ student: we can just say that any edge] everyedge get classified either as a tree edge or as a back edge rightlet me write this down so DFS classifies every edge as a tree or a backedge right this is similar to breadth first search means breadth firstsearch classifies every edge as as as an edge going between adjacent levelsor going between a level within the same level lets see right[Refer Slide: 36.49]                                    [pic]so here breadth first search depth first search also does thing for usclear to everyone okay we are still talking about depth first search inundirected graphs though when we come to directed graphs things will changea bit right keep that in mind okayhow do we implement depth first search looks like a fairly complicatedthing right stacks [student: or recursion]  or recursion right okaylets see so what are the things we needed we said we have to keep trackwell of whether a vertex is visited or its not visited right whetherwhat the color of a vertex is so actually we don't even need to distinguishbetween grey and blackwe just need to distinguish a between [student: white and ] white and nonwhite whether a vertex is visited or not visitedthat was the only thing we really needed right so we are going to keep anarray called visited rightso what will this have basically it will have a entry for every vertex fora vertex v it will have a entrylets say zero or one zero if it is not visited and one if it is visitedright this is a zero one entryzero means not visited right initially all the entries of this array wouldbe  a zero [hindi] rightso suppose I wanted to do depth first search starting from a vertex v in mygraph right so now my graph is going to become more abstractthis is my graph this is a vertex v right and I am I want to do a depthfirst search from this vertex [noise]so what am I going to do what does depth first search involve what is thefirst thing I should do [student: noise]so first I should mark this vertex as visited right clearly lets say thisis the very first thing I dovisited v equals one [student: um] pardon [student: um]now I have to look at all the vertices one after the other adjacentverticesso lets say this had three adjacent vertices x y zso lets put down a loop for all w adjacent to v do something for allvertices w so w is just a running variable so to say which will take thevalue x y or z depending upon which this is yeahwhat should I do [student: um doffs dfs dfs w um]i just do visited dfs w right away no [student: um]if it is not visited if visited w [student: equal to one] equal to zero ifnot visited w not of visited w then then [student: dfs] then just say DFS wyeah [hindi] else [student: no else how can you define um] no else no elsethen what [student: the else w will backtrack]backtrack [student: else backtrack um if for all w ] for all w over [hindi][student: not of visited of w then we backtrack visited w equal to one ]visited w equal to one [hindi]if it has no w then [student: sir predecessor] backtrack [student: [hindi]if all w is not visited then we backtrack to the predecessor um sir afterwe have done ]basically [hindi] but this takes care of everything for usall our backtracking everything it is not trivial to understand this partright why it is taking care of all the things for us yeah [hindi]for all [student: adjacent vertices] [hindi] all adjacent vertices [hindi]but you know to convenience yourself that this is doing all of thatyou know recursion is not magic right its after all this is just a piece ofcourt [hindi]so it is particularly well suited for depth first search rightyou can write three line program four line program for something we spentthirty minutes[Refer Slide: 43.19]                      
# binheap-7
              [pic]you know telling what the procedure is yeah okay so what is that ishappening why is this working out for us yeahso lets try and understand that and I will just okayI think I will just explain it on this this picture rightI started a depth first search from v right this is what my depth firstsearch v was rightlets say the vertices where considered in this order exactly this order x yz yeah visited v is one visited x y z are all zeroas are visited of all the other vertices I just started my depth firstsearch here then I came to this vertexsince visited of x is zero I launched a depth first search here yeah that'swhat we would have done hereI launched depth first search on this what is this depth first search goingto do lets say our depth first search visits a certain bunch of verticeswhich are not already visited and marks them visited one as a consequencethis guy is going to visit a bunch of vertices and set visited one for eachone of them visited at one and then it is going to terminateevery program has to terminate it also terminates but what is it thatterminates DFS on xso when DFS on x terminates this recursive call terminates where do we endup we end up when this terminates we end up in the DFS of v because this isthe DFS which called DFS x rightso the picture is something like the following you had DFS v making a callto DFS x this did a lot of recursive calls but at some point it terminatedafter it terminated we made a call to DFS y [noise]when you made a call to DFS y why did we make a DFS y well because we arelooking at all the adjacent vertices and I am assuming for now that y wasnot visited in this DFSsuppose it was not visited so it was still at zero so I made a call to DFSy now as a consequence it visited another bunch of vertices yeah it would not have visited any vertex which was already visited by x that'swe are ensuring that not going to a vertex whose visited is already set toa oneso it visited another bunch of vertices and then it terminatednow I am going to vertex z and try to launch a DFS there but I see that zis already visitedbecause z was set to visited when I did my DFS y um when that happens z isalready visitedso I don't launch a DFS here so I have taken care all adjacent vertices andso this terminates nowthis terminates means DFS on v terminates this whole process terminatesright the claim is I would have all the vertices that were to be visited[hindi]from this vertex which are the vertices I can reach if I reach a certainvertex either I can reach it through x or through y or through zbecause after all these are the only three edges incident at this vertex ifI can reach it from xthen that means it should have been visited in DFS x if it I can reach itfrom y it should have been reachable from DFS y if I can reach it from zit should also have been reachable from DFS y why because z is reachablefrom y if z is reachable from ythen after I had reached z I would have continued and visited all verticeswhich can be reached from zso anything that is reachable from v therefore is visited and so our DFSfrom v should terminate and that is exactly what is being done here yeah[noise]we are not done with this yet as you can imagine rightI want to add my timestamps how should I modify this procedure [student: umstarts] right so suppose with each vertex I want not juts visited but Ihave two other arrays um arrivallets call it a and departure lets call it d right so a of v so this is alsoan array and this is also an array rightit is not a zero one array sorry so this zero one was for the previousthing so if I have a vertex uso a of u will be an integer which will tell me what time I reached vertexu and d of u would be another integerwhich will tell me at what time I left vertex u what modification should Imake to this piece of [student: um when d of u um] um [student: a of ucomes um when you start DFS v um after visited]so a of u equals [student: plus plus b plus whatever] time plus plus[student: and after DFS not after after DFS w after] [hindi] [student:after the for loop] [hindi]its juts saying stamp and increment so that the next 
# binheap-8
 doesn't get thesame stampit could be plus plus time or time plus plus doesn't make too much ofdifference rightit will just change the starting yes no so and time could initially be zero[hindi]great okay you can also modify this procedure to identify which edge is atree edge and which edge is a back edge can you do that[student: um if visited w] um [student: for DFS w we can mark its edge um]rightso what should where should I so suppose I also wanted this informationevery edge which is a tree edgeI want to mark the tree edge[student: with um is equal to one then] then in this then so when I amready to launch DFS w then that meanswhat does that mean what can I conclude at this point [student: noise]which edge v w [student: v um]the edge v um v w is a tree edge that I can conclude right [hindi] I canwrite that statement yeah [hindi][Refer Slide: 52.48]                                    [pic]v w is a tree edge if you identified what the tree edge is are then itsequivalent to identifying what the back edges are anything which is not atree edge is a back edge right that how do you know52.56 greatso I am going to stop here today um in the next class we are going to seeto analyze the running time of this procedure and we are going to spend acouple of classes in applications of depth first search yeah okay 
